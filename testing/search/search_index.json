{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"Make your web services secure by default ! <p>Introducing BunkerWeb, the cutting-edge and open-source Web Application Firewall (WAF) that will revolutionize your web security experience.</p> <p>With BunkerWeb, your web services are safeguarded by default, providing you with peace of mind and enhanced protection. Powered by NGINX, this comprehensive web server combines advanced features seamlessly, ensuring your online assets remain secure.</p> <p>BunkerWeb effortlessly integrates into your existing environments, whether it's Linux, Docker, Swarm, Kubernetes, or more. Its versatility allows for easy configuration to suit your specific requirements. Don't worry if you prefer a user-friendly interface\u2014BunkerWeb offers an exceptional web UI alongside the command-line interface (CLI), ensuring accessibility for all users.</p> <p>Experience the transformation in cybersecurity, where complexities and obstacles are a thing of the past. With BunkerWeb, fortifying your digital assets has never been more delightful and hassle-free.</p> <p>Furthermore, BunkerWeb boasts a comprehensive set of primary security features at its core. However, what sets it apart is its remarkable flexibility through an intuitive plugin system. This ingenious design empowers you to effortlessly enhance BunkerWeb with additional security measures, ensuring a tailored and robust defense for your web applications.</p> <p>By seamlessly integrating new plugins into BunkerWeb, you can customize and expand its capabilities to address specific security requirements unique to your environment. Whether you need to strengthen authentication protocols, bolster threat detection, or implement specialized security measures, BunkerWeb's plugin system grants you the freedom to fortify your web infrastructure with ease.</p> <p>With BunkerWeb's dynamic plugin system, security becomes an enjoyable journey of exploration and empowerment. Discover the endless possibilities and create a fortified web environment that perfectly aligns with your needs.</p>"},{"location":"#why-bunkerweb","title":"Why BunkerWeb ?","text":"<ul> <li> <p>Easy integration into existing environments : Seamlessly integrate BunkerWeb into various environments such as Linux, Docker, Swarm, Kubernetes, Ansible, Vagrant, and more. Enjoy a smooth transition and hassle-free implementation.</p> </li> <li> <p>Highly customizable : Tailor BunkerWeb to your specific requirements with ease. Enable, disable, and configure features effortlessly, allowing you to customize the security settings according to your unique use case.</p> </li> <li> <p>Secure by default : BunkerWeb provides out-of-the-box, hassle-free minimal security for your web services. Experience peace of mind and enhanced protection right from the start.</p> </li> <li> <p>Awesome web UI : Take control of BunkerWeb more efficiently with the exceptional web user interface (UI). Navigate settings and configurations effortlessly through a user-friendly graphical interface, eliminating the need for the command-line interface (CLI).</p> </li> <li> <p>Plugin system : Extend the capabilities of BunkerWeb to meet your own use cases. Seamlessly integrate additional security measures and customize the functionality of BunkerWeb according to your specific requirements.</p> </li> <li> <p>Free as in \"freedom\" : BunkerWeb is licensed under the free AGPLv3 license, embracing the principles of freedom and openness. Enjoy the freedom to use, modify, and distribute the software, backed by a supportive community.</p> </li> </ul>"},{"location":"#security-features","title":"Security features","text":"<p>Explore the impressive array of security features offered by BunkerWeb. While not exhaustive, here are some notable highlights:</p> <ul> <li> <p>HTTPS support with transparent Let's Encrypt automation : Easily secure your web services with automated Let's Encrypt integration, ensuring encrypted communication between clients and your server.</p> </li> <li> <p>State-of-the-art web security : Benefit from cutting-edge web security measures, including comprehensive HTTP security headers, prevention of data leaks, and TLS hardening techniques.</p> </li> <li> <p>Integrated ModSecurity WAF with the OWASP Core Rule Set : Enjoy enhanced protection against web application attacks with the integration of ModSecurity, fortified by the renowned OWASP Core Rule Set.</p> </li> <li> <p>Automatic ban of strange behaviors based on HTTP status code : BunkerWeb intelligently identifies and blocks suspicious activities by automatically banning behaviors that trigger abnormal HTTP status codes.</p> </li> <li> <p>Apply connections and requests limit for clients : Set limits on the number of connections and requests from clients, preventing resource exhaustion and ensuring fair usage of server resources.</p> </li> <li> <p>Block bots with challenge-based verification : Keep malicious bots at bay by challenging them to solve puzzles such as cookies, JavaScript tests, captcha, hCaptcha, reCAPTCHA or Turnstile, effectively blocking unauthorized access.</p> </li> <li> <p>Block known bad IPs with external blacklists and DNSBL : Utilize external blacklists and DNS-based blackhole lists (DNSBL) to proactively block known malicious IP addresses, bolstering your defense against potential threats.</p> </li> <li> <p>And much more... : BunkerWeb is packed with a plethora of additional security features that go beyond this list, providing you with comprehensive protection and peace of mind.</p> </li> </ul> <p>To delve deeper into the core security features, we invite you to explore the security tuning section of the documentation. Discover how BunkerWeb empowers you to fine-tune and optimize security measures according to your specific needs.</p>"},{"location":"#demo","title":"Demo","text":"<p>A demo website protected with BunkerWeb is available at demo.bunkerweb.io. Feel free to visit it and perform some security tests.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#who-maintains-bunkerweb","title":"Who maintains BunkerWeb ?","text":"<p>BunkerWeb is maintained by Bunkerity, a French \ud83c\uddeb\ud83c\uddf7 company specialized in Cybersecurity \ud83d\udee1\ufe0f.</p>"},{"location":"about/#do-you-offer-professional-services","title":"Do you offer professional services ?","text":"<p>Yes, we offer professional services related to BunkerWeb such as :</p> <ul> <li>Consulting</li> <li>Support</li> <li>Custom development</li> <li>Partnership</li> </ul> <p>Please contact us at contact@bunkerity.com if you are interested.</p>"},{"location":"about/#where-to-get-community-support","title":"Where to get community support ?","text":"<p>To get free community support, you can use the following medias :</p> <ul> <li>The #help channel of BunkerWeb in the Discord server</li> <li>The help category of GitHub dicussions</li> <li>The /r/BunkerWeb subreddit</li> <li>The Server Fault and Super User forums</li> </ul> <p>Please don't use GitHub issues to ask for help, use it only for bug reports and feature requests.</p>"},{"location":"about/#how-can-i-contribute","title":"How can I contribute ?","text":"<p>Here is a non-exhaustive list of what you can do :</p> <ul> <li>Join the Discord server, /r/BunkerWeb subreddit and GitHub discussions to talk about the project and help others</li> <li>Follow us on LinkedIn, Twitter and GitHub</li> <li>Report bugs and propose new features using issues</li> <li>Contribute to the code using pull requests</li> <li>Write an awesome plugin</li> <li>Talk about BunkerWeb to your friends/colleagues, on social media, on your blog, ...</li> </ul>"},{"location":"about/#how-to-report-security-issue","title":"How to report security issue ?","text":"<p>Please contact us at security@bunkerity.com using the following PGP key :</p> <pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGCEMiMBEACtXJBDbF86qjC/Q1cfmJfYcYrbk6eE5czknG294XObC97wAgDf\n/MbX6bnti4kDRpflGDqQtwOXudcEzledTD4bdDUKvZwqPoYQGa24uCuUxSINTLXr\nRuoMaKfpvs7trsFXp5iYUqf4Org2aaJE7Tk/9sOvxgdqsT22jEgCZXTRU1qG494U\nu6XRQN8hKlw6aa6njjX9vUk6Jpl46/kwwO9mpXBZX6iFKYnBlUWs2k8d6D6cO5aZ\nKLoYyz5v3Gw2hHSqj4qbVQPTIT7qrrcfd8nblYK7Dh3IM+vQq7a7lB0AudIyBNPd\nrsypi9ZYgwI3lv/rmQnDc32Ua5cLvTvgg/XoaNK9ogc3kei1+hXODEgRA/zvSKqq\n20i/1Y0OnIGv89LOI6urWpOgDAhQUV5xvANll2lm3Bkmy29UOzNadUc/yImxrM06\nHwX82ju6PFAqOaxMW6SEE71ylGOSlikAGNcmmc5Ihd1J/VRZA4PBiQ31gQxFRpUC\n3NTw2QNAD1kjni5PuQD10Q1Ognvb6uJh/MtqsoX6r1t+Oly9MblFSuyqFkqNO3F0\nQAJqprhJlQ3YOcJdJ1EZR7qs0xJm5h+lw0Z/UINqkwiZUW3PCO8BKxfq6sfdwM8L\n5hPhyUzy2gIJ0J/4NGYEBH1ojoYODGU8OCSmyjSTY9SoVMeWDfqYP4ZTvQARAQAB\ntCVidW5rZXJpdHktcGdwIDxjb250YWN0QGJ1bmtlcml0eS5jb20+iQJUBBMBCAA+\nFiEEw78SjkcVxXCq7hStPYCAbxJgKnwFAmCEMiMCGwMFCQPCIP0FCwkIBwIGFQoJ\nCAsCBBYCAwECHgECF4AACgkQPYCAbxJgKnzvYhAAnNqGB6ce2eZzwk1EiNlNaXaA\nhFWLq/s/J1IOAP+0V5jKJxA6zTX01HyIfIIHQy6nrxxEXzYsIUHdJ+HBPCNswCqn\n2d/aDkkfoEUc1bUD0c2bXfoSCsAeIoK+eOf6iSr4IENVoIUYFQTUKFNu+Y7eDL0I\nJ8Xadg53G+fkK9LE6TeYpBs3hDT4w7vlDfIwWa1NC9HoLzSmZ2fqZ7SnihLGsLmp\n98VqDrDjhRPzrz5/tVYgvPCQQU5ED/TayCCYvrGpw9gP8qmEOabIUz0ppGwEfQVs\nWycilm1/Js/qjdbxUFMipBIzDu7bI3kMLmENhI+16Xtub9dUrvkW2SdDngYhtWj8\nIzVOe6N/XDuiRGpaYFpEuXbrnDFexe1ygZwnVHt3fukPfa7W8mhMs2kY1ishIA0O\nWElKO1Q6N0ZWEad0PwM8NCDjaDUNWQC36ZF/MS+ipHWx9joPUjImY2AXDjN+L+Si\nABQIe4Fo6Jx6S6Bi8YvPq8idYZvaWFJjBvmaPjxdUMPbIsMRiEjvlrhvqhLuVBpE\nlGA+M4UJGw5yBl+yiiLDuws/Fppv9HwNqw6Uq1m1XaW859Om1GGBKYfphyn+fHjR\n7ftOuT7Ss4zioXT4mscOZgkfzDAqgpZiHjYhe7tLUu7iD6UEsZmey/gRV0hCxng3\nN7yaRrBu0+3sIQV4jYC5Ag0EYIQyIwEQALSurJGOx7At5mRFjvhXd4/JHuBZZOSI\nM45LSJ+mKYnAGmwsL0AneZMIf6Yc0Vcn32oqlIXN5aB8jIt91pChLre8tl/lFZZP\nxY3WIEBJhZF0FIUqSQLjg4HD0S70REii7Om1kgtZueid8V6T5F1JDcO2mDoh8oc9\nh9nRQ1Ld6dblEuwBzbFkI1K6OUk1+ec7+mQc7orHdBVgelmqwG7fGZnPiN3XfklF\ndnwSkFIX/qkAsKQmmx1VSzaGFoPLajf4wrkzZdA3iEafsHyvdEFlezZCZ7TsoHBh\ntNg1Psg6MbBVgiMfHyRHSEBJZ7r5Awj2MpFUFMOd1IPcor1I254mx0VYfCvof4Km\nRi1F/86kHc23A77pd4HFYZWiZjaWhh12L+wz5fDL5/sSFXVGSCtSWIKx6FjysZ+v\nszk3lItHoomZhA7M+FjU/cOjq9hae9uwZeU39DQk0/npln2RcHitoqgUIzII5woO\nS3SlMSc910tHf40D2cBr1iFKC0jQICjkDexB9CtNx/N25SJmLfiimYtk6/NHlPq4\nHXdq6ZfLZ7xQmuGcyWv4f0pwA2CK3twISpsIxIKe456WYTDtQu9d1s987dvmw6F/\nqURC6m2WPGroHb8COQTKzbshjpGUmLpyR3FXki4wNXeI1KaQLL7NpZmK6yJlWviO\n1sCjh4m7VS+zABEBAAGJAjwEGAEIACYWIQTDvxKORxXFcKruFK09gIBvEmAqfAUC\nYIQyIwIbDAUJA8Ig/QAKCRA9gIBvEmAqfP2WEACqmXEhu4ARl2yT9bay0+W3F1q1\nMrLQkcVOau2ihXx3PhYsXRUoEFj72VDAar41WIlHsPJfB14WtSlYcX2XdjHLHMpC\ndL2eGhqIcHzFChR0vGjtvm2wae/rJTChWf8WXiHrRnRcfFFfhpCvkNi43fQeH4yp\ncel2a35WV+IRbnkCkaly2NG3XO0t83Siok8Ku+OJGPatUMxJmaEVQeeXVPDzVRva\nrtvyd9Sclkd9QDPBLZyWHC1vsPKGRJpi5uDZjGxhaFRkimw/SYtFHj7AUrMKAIHB\nGfEcwC3Eq4rF0FeCOPfBd2vwGGrRflx76jK9rj288ta9Oq6u6ev8PCVzt0E7jrSf\nAX88vfVRcxihNfj/9i5xmY596jpgbvNA2aJX2hAO3Q8pD6AunVXPUyc3RlFHt7jC\ntL+9Xv7Qwjz7OToWqj+9cM6T+6oZLxYNVPT72Z/KOFW+mzGb87qjcsDMb/hu2fNq\ntSWyZk2AAgHQyG1y8vCQQzsDnUDM6NIPwYG5XMP+11WAsPk5fP1ksixpUqIWgjhY\nM22YUsjLeaRtgSmhAGIkbBgecs1EHSZZ6sf2lB8gSom1wW0UCBPSifP0DwYFizS5\nSOk62kZ0lqEctwgKDe3MNQnPxt9+tU9L1pIkyXgXihcOLiCMl434K0djJXxIbiX0\nJvbFAfI3qteepvnjBQ==\n=g1tf\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#integrations","title":"Integrations","text":"<p>The first concept is the integration of BunkerWeb into the target environment. We prefer to use the word \"integration\" instead of \"installation\" because one of the goals of BunkerWeb is to integrate seamlessly into existing environments.</p> <p>The following integrations are officially supported :</p> <ul> <li>Docker</li> <li>Docker autoconf</li> <li>Swarm</li> <li>Kubernetes</li> <li>Linux</li> <li>Ansible</li> <li>Vagrant</li> </ul> <p>If you think that a new integration should be supported, do not hesitate to open a new issue on the GitHub repository.</p> <p>Going further</p> <p>The technical details of all BunkerWeb integrations are available in the integrations section of the documentation.</p>"},{"location":"concepts/#settings","title":"Settings","text":"<p>Once BunkerWeb is integrated into your environment, you will need to configure it to serve and protect your web applications.</p> <p>The configuration of BunkerWeb is done by using what we call the \"settings\" or \"variables\". Each setting is identified by a name such as <code>AUTO_LETS_ENCRYPT</code> or <code>USE_ANTIBOT</code>. You can assign values to the settings to configure BunkerWeb.</p> <p>Here is a dummy example of a BunkerWeb configuration :</p> <pre><code>SERVER_NAME=www.example.com\nAUTO_LETS_ENCRYPT=yes\nUSE_ANTIBOT=captcha\nREFERRER_POLICY=no-referrer\nUSE_MODSECURITY=no\nUSE_GZIP=yes\nUSE_BROTLI=no\n</code></pre> <p>Going further</p> <p>The complete list of available settings with descriptions and possible values is available in the settings section of the documentation.</p> <p>Settings generator tool</p> <p>To help you tune BunkerWeb, we offer an easy-to-use settings generator tool available at config.bunkerweb.io.</p>"},{"location":"concepts/#multisite-mode","title":"Multisite mode","text":"<p>Understanding the multisite mode is essential when utilizing BunkerWeb. As our primary focus is safeguarding web applications, our solution is intricately linked to the concept of \"virtual hosts\" or \"vhosts\" (more info here). These virtual hosts enable the serving of multiple web applications from a single instance or cluster.</p> <p>By default, BunkerWeb has the multisite mode disabled. This means that only one web application will be served, and all settings will be applied to it. This setup is ideal when you have a single application to protect, as you don't need to concern yourself with multisite configurations.</p> <p>However, when the multisite mode is enabled, BunkerWeb becomes capable of serving and protecting multiple web applications. Each web application is identified by a unique server name and has its own set of settings. This mode proves beneficial when you have multiple applications to secure, and you prefer to utilize a single instance (or a cluster) of BunkerWeb.</p> <p>The activation of the multisite mode is controlled by the <code>MULTISITE</code> setting, which can be set to <code>yes</code> to enable it or <code>no</code> to keep it disabled (which is the default value).</p> <p>Each setting within BunkerWeb has a specific context that determines where it can be applied. If the context is set to \"global,\" the setting can't be applied per server or site but is instead applied to the entire configuration as a whole. On the other hand, if the context is \"multisite,\" the setting can be applied globally and per server. To define a multisite setting for a specific server, simply add the server name as a prefix to the setting name. For example, <code>app1.example.com_AUTO_LETS_ENCRYPT</code> or <code>app2.example.com_USE_ANTIBOT</code> are examples of setting names with server name prefixes. When a multisite setting is defined globally without a server prefix, all servers inherit that setting. However, individual servers can still override the setting if the same setting is defined with a server name prefix.</p> <p>Understanding the intricacies of multisite mode and its associated settings allows you to tailor BunkerWeb's behavior to suit your specific requirements, ensuring optimal protection for your web applications.</p> <p>Here's a dummy example of a multisite BunkerWeb configuration :</p> <pre><code>MULTISITE=yes\nSERVER_NAME=app1.example.com app2.example.com app3.example.com\nAUTO_LETS_ENCRYPT=yes\nUSE_GZIP=yes\nUSE_BROTLI=yes\napp1.example.com_USE_ANTIBOT=javascript\napp1.example.com_USE_MODSECURITY=no\napp2.example.com_USE_ANTIBOT=cookie\napp2.example.com_WHITELIST_COUNTRY=FR\napp3.example.com_USE_BAD_BEHAVIOR=no\n</code></pre> <p>Going further</p> <p>You will find concrete examples of multisite mode in the quickstart guide of the documentation and the examples directory of the repository.</p>"},{"location":"concepts/#custom-configurations","title":"Custom configurations","text":"<p>To address unique challenges and cater to specific use cases, BunkerWeb offers the flexibility of custom configurations. While the provided settings and external plugins cover a wide range of scenarios, there may be situations that require additional customization.</p> <p>BunkerWeb is built on the renowned NGINX web server, which provides a powerful configuration system. This means you can leverage NGINX's configuration capabilities to meet your specific needs. Custom NGINX configurations can be included in various contexts such as HTTP or server, allowing you to fine-tune the behavior of BunkerWeb according to your requirements. Whether you need to customize global settings or apply configurations to specific server blocks, BunkerWeb empowers you to optimize its behavior to align perfectly with your use case.</p> <p>Another integral component of BunkerWeb is the ModSecurity Web Application Firewall. With custom configurations, you have the flexibility to address false positives or add custom rules to further enhance the protection provided by ModSecurity. These custom configurations allow you to fine-tune the behavior of the firewall and ensure that it aligns with the specific requirements of your web applications.</p> <p>By leveraging custom configurations, you unlock a world of possibilities to tailor BunkerWeb's behavior and security measures precisely to your needs. Whether it's adjusting NGINX configurations or fine-tuning ModSecurity, BunkerWeb provides the flexibility to meet your unique challenges effectively.</p> <p>Going further</p> <p>You will find concrete examples of custom configurations in the quickstart guide of the documentation and the examples directory of the repository.</p>"},{"location":"concepts/#database","title":"Database","text":"<p>BunkerWeb securely stores its current configuration in a backend database, which contains essential data for smooth operation. The following information is stored in the database:</p> <ul> <li> <p>Settings for all services: The database holds the defined settings for all the services provided by BunkerWeb. This ensures that your configurations and preferences are preserved and readily accessible.</p> </li> <li> <p>Custom configurations: Any custom configurations you create are also stored in the backend database. This includes personalized settings and modifications tailored to your specific requirements.</p> </li> <li> <p>BunkerWeb instances: Information about BunkerWeb instances, including their setup and relevant details, is stored in the database. This allows for easy management and monitoring of multiple instances if applicable.</p> </li> <li> <p>Metadata about job execution: The database stores metadata related to the execution of various jobs within BunkerWeb. This includes information about scheduled tasks, maintenance processes, and other automated activities.</p> </li> <li> <p>Cached files: BunkerWeb utilizes caching mechanisms for improved performance. The database holds cached files, ensuring efficient retrieval and delivery of frequently accessed resources.</p> </li> </ul> <p>Under the hood, whenever you edit a setting or add a new configuration, BunkerWeb automatically stores the changes in the database, ensuring data persistence and consistency. BunkerWeb supports multiple backend database options, including SQLite, MariaDB, MySQL, and PostgreSQL.</p> <p>Configuring the database is straightforward using the <code>DATABASE_URI</code> setting, which follows the specified formats for each supported database:</p> <ul> <li>SQLite: <code>sqlite:///var/lib/bunkerweb/db.sqlite3</code></li> <li>MariaDB: <code>mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db</code></li> <li>MySQL: <code>mysql+pymysql://bunkerweb:changeme@bw-db:3306/db</code></li> <li>PostgreSQL: <code>postgresql://bunkerweb:changeme@bw-db:5432/db</code></li> </ul> <p>By specifying the appropriate database URI in the configuration, you can seamlessly integrate BunkerWeb with your preferred database backend, ensuring efficient and reliable storage of your configuration data.</p> <p> </p> Database Schema"},{"location":"concepts/#scheduler","title":"Scheduler","text":"<p>For seamless coordination and automation, BunkerWeb employs a specialized service known as the scheduler. The scheduler plays a vital role in ensuring smooth operation by performing the following tasks:</p> <ul> <li> <p>Storing settings and custom configurations: The scheduler is responsible for storing all the settings and custom configurations within the backend database. This centralizes the configuration data, making it easily accessible and manageable.</p> </li> <li> <p>Executing various tasks (jobs): The scheduler handles the execution of various tasks, referred to as jobs. These jobs encompass a range of activities, such as periodic maintenance, scheduled updates, or any other automated tasks required by BunkerWeb.</p> </li> <li> <p>Generating BunkerWeb configuration: The scheduler generates a configuration that is readily understood by BunkerWeb. This configuration is derived from the stored settings and custom configurations, ensuring that the entire system operates cohesively.</p> </li> <li> <p>Acting as an intermediary for other services: The scheduler acts as an intermediary, facilitating communication and coordination between different components of BunkerWeb. It interfaces with services such as the web UI or autoconf, ensuring a seamless flow of information and data exchange.</p> </li> </ul> <p>In essence, the scheduler serves as the brain of BunkerWeb, orchestrating various operations and ensuring the smooth functioning of the system.</p> <p>Depending on the integration approach, the execution environment of the scheduler may differ. In container-based integrations, the scheduler is executed within its dedicated container, providing isolation and flexibility. On the other hand, for Linux-based integrations, the scheduler is self-contained within the bunkerweb service, simplifying the deployment and management process.</p> <p>By employing the scheduler, BunkerWeb streamlines the automation and coordination of essential tasks, enabling efficient and reliable operation of the entire system.</p>"},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/#docker","title":"Docker","text":"Docker integration <p>Utilizing BunkerWeb as a Docker container offers a convenient and straightforward approach for testing and utilizing the solution, particularly if you are already familiar with Docker technology.</p> <p>To facilitate your Docker deployment, we provide readily available prebuilt images on Docker Hub, supporting multiple architectures. These prebuilt images are optimized and prepared for use on the following architectures:</p> <ul> <li>x64 (64-bit)</li> <li>x86</li> <li>armv8 (ARM 64-bit)</li> <li>armv7 (ARM 32-bit)</li> </ul> <p>By accessing these prebuilt images from Docker Hub, you can quickly pull and run BunkerWeb within your Docker environment, eliminating the need for extensive configuration or setup processes. This streamlined approach allows you to focus on leveraging the capabilities of BunkerWeb without unnecessary complexities.</p> <p>Whether you're conducting tests, developing applications, or deploying BunkerWeb in production, the Docker containerization option provides flexibility and ease of use. Embracing this method empowers you to take full advantage of BunkerWeb's features while leveraging the benefits of Docker technology.</p> <pre><code>docker pull bunkerity/bunkerweb:1.5.1\n</code></pre> <p>Alternatively, if you prefer a more hands-on approach, you have the option to build the Docker image directly from the source. Building the image from source gives you greater control and customization over the deployment process. However, please note that this method may take some time to complete, depending on your hardware configuration.</p> <p>While the image is being built, you can take a moment to relax and enjoy a cup of coffee \u2615, as the process may require some patience. Once the image is successfully built, you can proceed to deploy and utilize BunkerWeb within your Docker environment. This method allows you to tailor the image to your specific requirements and ensures a more personalized deployment of BunkerWeb.</p> <p>So, whether you choose to use the ready-to-use prebuilt images or embark on the journey of building the image from source, BunkerWeb in Docker provides you with the flexibility and options to seamlessly integrate it into your environment.</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb.git &amp;&amp; \\\ncd bunkerweb &amp;&amp; \\\ndocker build -t my-bunkerweb -f src/bunkerweb/Dockerfile .\n</code></pre> <p>Docker integration key concepts are :</p> <ul> <li>Environment variables to configure BunkerWeb</li> <li>Scheduler container to store configuration and execute jobs</li> <li>Networks to expose ports for clients and connect to upstream web services</li> </ul> <p>When integrating BunkerWeb with Docker, there are key concepts to keep in mind, ensuring a smooth and efficient deployment:</p> <ul> <li> <p>Environment variables: BunkerWeb can be easily configured using environment variables. These variables allow you to customize various aspects of BunkerWeb's behavior, such as network settings, security options, and other parameters.</p> </li> <li> <p>Scheduler container: To effectively manage the configuration and execution of jobs, BunkerWeb utilizes a dedicated container called the scheduler.</p> </li> <li> <p>Networks: Docker networks play a vital role in the integration of BunkerWeb. These networks serve two main purposes: exposing ports to clients and connecting to upstream web services. By exposing ports, BunkerWeb can accept incoming requests from clients, allowing them to access the protected web services. Additionally, by connecting to upstream web services, BunkerWeb can efficiently route and manage the traffic, providing enhanced security and performance.</p> </li> </ul> <p>Database backend</p> <p>Please be aware that our instructions assume you are using SQLite as the default database backend, as configured by the <code>DATABASE_URI</code> setting. However, we understand that you may prefer to utilize alternative backends for your Docker integration. If that is the case, rest assured that other database backends are still possible. See docker-compose files in the misc/integrations folder folder of the repository for more information.</p>"},{"location":"integrations/#environment-variables","title":"Environment variables","text":"<p>Settings are passed to BunkerWeb using Docker environment variables :</p> <pre><code>...\nservices:\nmybunker:\nimage: bunkerity/bunkerweb:1.5.1\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- MY_SETTING=value\n- ANOTHER_SETTING=another value\n...\n</code></pre> <p>Please note that the <code>bunkerweb.INSTANCE</code> is mandatory to make sure the scheduler can detect BunkerWeb instance(s).</p> <p>Full list</p> <p>For the complete list of environment variables, see the settings section of the documentation.</p>"},{"location":"integrations/#scheduler","title":"Scheduler","text":"<p>The scheduler is executed in its own container which is also available on Docker Hub :</p> <pre><code>docker pull bunkerity/bunkerweb-scheduler:1.5.1\n</code></pre> <p>Alternatively, you can build the Docker image directly from the source (less coffee \u2615 needed than BunkerWeb image) :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb.git &amp;&amp; \\\ncd bunkerweb &amp;&amp; \\\ndocker build -t my-scheduler -f src/scheduler/Dockerfile .\n</code></pre> <p>A volume is needed to store the SQLite database that will be used by the scheduler :</p> <pre><code>...\nservices:\nmybunker:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nvolumes:\n- bw-data:/data\n...\nvolumes:\nbw-data:\n</code></pre> <p>Using local folder for persistent data</p> <p>The scheduler runs as an unprivileged user with UID 101 and GID 101 inside the container. The reason behind this is security : in case a vulnerability is exploited, the attacker won't have full root (UID/GID 0) privileges. But there is a downside : if you use a local folder for the persistent data, you will need to set the correct permissions so the unprivileged user can write data to it. Something like that should do the trick :</p> <pre><code>mkdir bw-data &amp;&amp; \\\nchown root:101 bw-data &amp;&amp; \\\nchmod 770 bw-data\n</code></pre> <p>Alternatively, if the folder already exists :</p> <pre><code>chown -R root:101 bw-data &amp;&amp; \\\nchmod -R 770 bw-data\n</code></pre> <p>If you are using Docker in rootless mode or podman, UIDs and GIDs in the container will be mapped to different ones in the host. You will first need to check your initial subuid and subgid :</p> <pre><code>grep ^$(whoami): /etc/subuid &amp;&amp; \\\ngrep ^$(whoami): /etc/subgid\n</code></pre> <p>For example, if you have a value of 100000, the mapped UID/GID will be 100100 (100000 + 100) :</p> <pre><code>mkdir bw-data &amp;&amp; \\\nsudo chgrp 100100 bw-data &amp;&amp; \\\nchmod 770 bw-data\n</code></pre> <p>Or if the folder already exists :</p> <p><code>shell sudo chgrp -R 100100 bw-data &amp;&amp; \\ chmod -R 770 bw-data</code></p> <p>When using Docker-based integrations, the scheduler will need to access the Docker API to get things working which is defined using the <code>DOCKER_HOST</code> environment variable.</p> <p>Docker API access and security</p> <p>Due to Docker's limitations in supporting fine-grained authorizations, it's important to be aware of the potential security risks associated with accessing the API directly. Accessing the Docker API can pose a threat, as an attacker with API access can potentially obtain root privileges on the host machine. For more detailed information on this topic, we encourage you to refer to the provided link (here).</p> <p>To mitigate these risks, we strongly advise against directly mounting the socket file located at <code>/var/run/docker.sock</code> within the BunkerWeb container. Instead, we recommend employing an alternative approach that enhances security. One such approach involves using a \"proxy\" container, such as <code>tecnativa/docker-socket-proxy</code>, which acts as an intermediary and allows only necessary API calls.</p> <p>By adopting this proxy container strategy, you can establish a more secure communication channel with the Docker API, minimizing the potential attack surface and enhancing overall system security.</p> <p>You will need to create the Docker API proxy container, mount the socket and set the <code>DOCKER_HOST</code> environment variable to use the Docker API proxy :</p> <pre><code>...\nservices:\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nenv:\n- DOCKER_HOST=tcp://bw-docker:2375\n...\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\n...\n</code></pre> <p>Docker socket in rootless mode</p> <p>If you are using Docker in rootless mode, you will need to replace the mount of the docker socket with the following value : <code>$XDG_RUNTIME_DIR/docker.sock:/var/run/docker.sock:ro</code>.</p>"},{"location":"integrations/#networks","title":"Networks","text":"<p>By default, BunkerWeb container is listening (inside the container) on 8080/tcp for HTTP and 8443/tcp for HTTPS.</p> <p>Privileged ports in rootless mode or when using podman</p> <p>If you are using Docker in rootless mode and want to redirect privileged ports (&lt; 1024) like 80 and 443 to BunkerWeb, please refer to the prerequisites here.</p> <p>If you are using podman you can lower the minimum number for unprivileged ports : <pre><code>sudo sysctl net.ipv4.ip_unprivileged_port_start=1\n</code></pre></p> <p>The typical BunkerWeb stack when using the Docker integration contains the following containers :</p> <ul> <li>BunkerWeb</li> <li>Scheduler</li> <li>Docker socket proxy</li> <li>Your services</li> </ul> <p>For defense in depth purposes, we strongly recommend to create at least three different Docker networks :</p> <ul> <li><code>bw-services</code> : for BunkerWeb and your web services</li> <li><code>bw-universe</code> : for BunkerWeb and scheduler</li> <li><code>bw-docker</code> : for scheduler and the Docker API proxy</li> </ul> <p>To secure the communication between the scheduler and BunkerWeb API, it is important to authorize API calls. You can use the <code>API_WHITELIST_IP</code> setting to specify allowed IP addresses and subnets. It is strongly recommended to use a static subnet for the <code>bw-universe</code> network to enhance security. By implementing these measures, you can ensure that only authorized sources can access the BunkerWeb API, reducing the risk of unauthorized access or malicious activities:</p> <pre><code>...\nservices:\nmybunker:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080\n- 443:8443\nnetworks:\n- bw-services\n- bw-universe\n...\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nnetworks:\n- bw-universe\n- bw-docker\n...\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nnetworks:\n- bw-docker\n...\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre>"},{"location":"integrations/#full-compose-file","title":"Full compose file","text":"<pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080\n- 443:8443\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- SERVER_NAME=www.example.com\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\nnetworks:\n- bw-universe\n- bw-services\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nvolumes:\n- bw-data:/data\nenvironment:\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre>"},{"location":"integrations/#docker-autoconf","title":"Docker autoconf","text":"Docker autoconf integration <p>Docker integration</p> <p>The Docker autoconf integration is an \"evolution\" of the Docker one. Please read the Docker integration section first if needed.</p> <p>An alternative approach is available to address the inconvenience of recreating the container every time there is an update. By utilizing another image called autoconf, you can automate the real-time reconfiguration of BunkerWeb without the need for container recreation.</p> <p>To leverage this functionality, instead of defining environment variables for the BunkerWeb container, you can add labels to your web application containers. The autoconf image will then listen for Docker events and seamlessly handle the configuration updates for BunkerWeb.</p> <p>This \"automagical\" process simplifies the management of BunkerWeb configurations. By adding labels to your web application containers, you can delegate the reconfiguration tasks to autoconf without the manual intervention of container recreation. This streamlines the update process and enhances convenience.</p> <p>By adopting this approach, you can enjoy real-time reconfiguration of BunkerWeb without the hassle of container recreation, making it more efficient and user-friendly.</p> <p>Multisite mode</p> <p>The Docker autoconf integration implies the use of multisite mode. Please refer to the multisite section of the documentation for more information.</p> <p>Database backend</p> <p>Please be aware that our instructions assume you are using MariaDB as the default database backend, as configured by the <code>DATABASE_URI</code> setting. However, we understand that you may prefer to utilize alternative backends for your Docker integration. If that is the case, rest assured that other database backends are still possible. See docker-compose files in the misc/integrations folder folder of the repository for more information.</p> <p>To enable automated configuration updates, include an additional container called <code>bw-autoconf</code> in the stack. This container hosts the autoconf service, which manages dynamic configuration changes for BunkerWeb. To support this functionality, use a dedicated \"real\" database backend (e.g., MariaDB, MySQL, or PostgreSQL) for synchronized configuration storage. By integrating <code>bw-autoconf</code> and a suitable database backend, you establish the infrastructure for seamless automated configuration management in BunkerWeb.</p> <pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080\n- 443:8443\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- SERVER_NAME=\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- AUTOCONF_MODE=yes\n- MULTISITE=yes\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\nnetworks:\n- bw-universe\n- bw-services\n\nbw-autoconf:\nimage: bunkerity/bunkerweb-autoconf:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- AUTOCONF_MODE=yes\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- DOCKER_HOST=tcp://bw-docker:2375\n- AUTOCONF_MODE=yes\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nbw-db:\nimage: mariadb:10.10\nenvironment:\n- MYSQL_RANDOM_ROOT_PASSWORD=yes\n- MYSQL_DATABASE=db\n- MYSQL_USER=bunkerweb\n- MYSQL_PASSWORD=changeme\nvolumes:\n- bw-data:/var/lib/mysql\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>Database in the <code>bw-docker</code> network</p> <p>The database container is intentionally not included in the <code>bw-universe</code> network. It is used by the <code>bw-autoconf</code> and <code>bw-scheduler</code> containers rather than directly by BunkerWeb. Therefore, the database container is part of the <code>bw-docker</code> network, which enhances security by making external access to the database more challenging. This deliberate design choice helps safeguard the database and strengthens the overall security perspective of the system.</p> <p>Using Docker in rootless mode</p> <p>If you are using Docker in rootless mode, you will need to replace the mount of the docker socket with the following value : <code>$XDG_RUNTIME_DIR/docker.sock:/var/run/docker.sock:ro</code>.</p> <p>Once the stack is set up, you will be able to create the web application container and add the settings as labels using the \"bunkerweb.\" prefix in order to automatically set up BunkerWeb :</p> <pre><code>version: \"3.5\"\n\nservices:\nmyapp:\nimage: mywebapp:4.2\nnetworks:\nbw-services:\naliases:\n- myapp\nlabels:\n- \"bunkerweb.MY_SETTING_1=value1\"\n- \"bunkerweb.MY_SETTING_2=value2\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre>"},{"location":"integrations/#swarm","title":"Swarm","text":"Docker Swarm integration <p>Docker autoconf</p> <p>The Swarm integration is similar to the Docker autoconf one (but with services instead of containers). Please read the Docker autoconf integration section first if needed.</p> <p>To enable automatic configuration of BunkerWeb instances, the autoconf service requires access to the Docker API. This service listens for Docker Swarm events, such as service creation or deletion, and seamlessly configures the BunkerWeb instances in real-time without any downtime. It also monitors other Swarm objects, such as configs, for custom configurations.</p> <p>Similar to the Docker autoconf integration, configuration for web services is defined using labels that start with the bunkerweb  prefix.</p> <p>For an optimal setup, it is recommended to schedule the BunkerWeb service as a global service on all nodes, while the autoconf, scheduler, and Docker API proxy services should be scheduled as single replicated services. Please note that the Docker API proxy service needs to be scheduled on a manager node unless you configure it to use a remote API (which is not covered in the documentation).</p> <p>Since multiple instances of BunkerWeb are running, a shared data store implemented as a Redis service must be created. These instances will utilize the Redis service to cache and share data. Further details regarding the Redis settings can be found here.</p> <p>As for the database volume, the documentation does not specify a specific approach. Choosing either a shared folder or a specific driver for the database volume is dependent on your unique use-case and is left as an exercise for the reader.</p> <p>Database backend</p> <p>Please be aware that our instructions assume you are using MariaDB as the default database backend, as configured by the <code>DATABASE_URI</code> setting. However, we understand that you may prefer to utilize alternative backends for your Docker integration. If that is the case, rest assured that other database backends are still possible. See docker-compose files in the misc/integrations folder folder of the repository for more information.</p> <p>Clustered database backends setup are out-of-the-scope of this documentation.</p> <p>Here is the stack boilerplate that you can deploy using <code>docker stack deploy</code> :</p> <pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- published: 80\ntarget: 8080\nmode: host\nprotocol: tcp\n- published: 443\ntarget: 8443\nmode: host\nprotocol: tcp\nenvironment:\n- SERVER_NAME=\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\n- SWARM_MODE=yes\n- MULTISITE=yes\n- USE_REDIS=yes\n- REDIS_HOST=bw-redis\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\nnetworks:\n- bw-universe\n- bw-services\ndeploy:\nmode: global\nplacement:\nconstraints:\n- \"node.role == worker\"\nlabels:\n- \"bunkerweb.INSTANCE\"\n\nbw-autoconf:\nimage: bunkerity/bunkerweb-autoconf:1.5.1\nenvironment:\n- SWARM_MODE=yes\n- DOCKER_HOST=tcp://bw-docker:2375\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\nnetworks:\n- bw-universe\n- bw-docker\ndeploy:\nplacement:\nconstraints:\n- \"node.role == worker\"\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONFIGS=1\n- CONTAINERS=1\n- SERVICES=1\n- SWARM=1\n- TASKS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\ndeploy:\nplacement:\nconstraints:\n- \"node.role == manager\"\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nenvironment:\n- SWARM_MODE=yes\n- DOCKER_HOST=tcp://bw-docker:2375\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\nnetworks:\n- bw-universe\n- bw-docker\ndeploy:\nplacement:\nconstraints:\n- \"node.role == worker\"\n\nbw-db:\nimage: mariadb:10.10\nenvironment:\n- MYSQL_RANDOM_ROOT_PASSWORD=yes\n- MYSQL_DATABASE=db\n- MYSQL_USER=bunkerweb\n- MYSQL_PASSWORD=changeme\nvolumes:\n- bw-data:/var/lib/mysql\nnetworks:\n- bw-docker\ndeploy:\nplacement:\nconstraints:\n- \"node.role == worker\"\n\nbw-redis:\nimage: redis:7-alpine\nnetworks:\n- bw-universe\ndeploy:\nplacement:\nconstraints:\n- \"node.role == worker\"\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\ndriver: overlay\nattachable: true\nipam:\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\ndriver: overlay\nattachable: true\nbw-docker:\nname: bw-docker\ndriver: overlay\nattachable: true\n</code></pre> <p>Swarm mandatory setting</p> <p>Please note that the <code>SWARM_MODE=yes</code> environment variable is mandatory when using the Swarm integration.</p> <p>Once the BunkerWeb Swarm stack is set up and running (see autoconf and scheduler logs for more information), you will be able to deploy web applications in the cluster and use labels to dynamically configure BunkerWeb :</p> <pre><code>version: \"3.5\"\n\nservices:\nmyapp:\nimage: mywebapp:4.2\nnetworks:\n- bw-services\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.MY_SETTING_1=value1\"\n- \"bunkerweb.MY_SETTING_2=value2\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre>"},{"location":"integrations/#kubernetes","title":"Kubernetes","text":"Kubernetes integration <p>To automate the configuration of BunkerWeb instances in a Kubernetes environment, the autoconf service serves as an Ingress controller. It configures the BunkerWeb instances based on Ingress resources and also monitors other Kubernetes objects, such as ConfigMap, for custom configurations.</p> <p>For an optimal setup, it is recommended to define BunkerWeb as a DaemonSet, which ensures that a pod is created on all nodes, while the autoconf and scheduler are defined as single replicated Deployment.</p> <p>Given the presence of multiple BunkerWeb instances, it is necessary to establish a shared data store implemented as a Redis service. This Redis service will be utilized by the instances to cache and share data among themselves. Further information about the Redis settings can be found here.</p> <p>Database backend</p> <p>Please be aware that our instructions assume you are using MariaDB as the default database backend, as configured by the <code>DATABASE_URI</code> setting. However, we understand that you may prefer to utilize alternative backends for your Docker integration. If that is the case, rest assured that other database backends are still possible. See docker-compose files in the misc/integrations folder folder of the repository for more information.</p> <p>Clustered database backends setup are out-of-the-scope of this documentation.</p> <p>Please ensure that both the scheduler and autoconf services have access to the Kubernetes API. It is recommended to utilize RBAC authorization for this purpose.</p> <p>Additionally, it is crucial to set the <code>KUBERNETES_MODE</code> environment variable to <code>yes</code> when utilizing the Kubernetes integration. This variable is mandatory for proper functionality.</p> <p>To assist you, here is a YAML boilerplate that can serve as a foundation for your configuration:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: cr-bunkerweb\nrules:\n- apiGroups: [\"\"]\nresources: [\"services\", \"pods\", \"configmaps\"]\nverbs: [\"get\", \"watch\", \"list\"]\n- apiGroups: [\"networking.k8s.io\"]\nresources: [\"ingresses\"]\nverbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: sa-bunkerweb\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: crb-bunkerweb\nsubjects:\n- kind: ServiceAccount\nname: sa-bunkerweb\nnamespace: default\napiGroup: \"\"\nroleRef:\nkind: ClusterRole\nname: cr-bunkerweb\napiGroup: rbac.authorization.k8s.io\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\nname: bunkerweb\nspec:\nselector:\nmatchLabels:\napp: bunkerweb\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb\n# mandatory annotation\nannotations:\nbunkerweb.io/INSTANCE: \"yes\"\nspec:\ncontainers:\n# using bunkerweb as name is mandatory\n- name: bunkerweb\nimage: bunkerity/bunkerweb:1.5.1\nimagePullPolicy: Always\nsecurityContext:\nrunAsUser: 101\nrunAsGroup: 101\nallowPrivilegeEscalation: false\ncapabilities:\ndrop:\n- ALL\nports:\n- containerPort: 8080\nhostPort: 80\n- containerPort: 8443\nhostPort: 443\nenv:\n- name: KUBERNETES_MODE\nvalue: \"yes\"\n# replace with your DNS resolvers\n# e.g. : kube-dns.kube-system.svc.cluster.local\n- name: DNS_RESOLVERS\nvalue: \"coredns.kube-system.svc.cluster.local\"\n- name: USE_API\nvalue: \"yes\"\n# 10.0.0.0/8 is the cluster internal subnet\n- name: API_WHITELIST_IP\nvalue: \"127.0.0.0/8 10.0.0.0/8\"\n- name: SERVER_NAME\nvalue: \"\"\n- name: MULTISITE\nvalue: \"yes\"\n- name: USE_REDIS\nvalue: \"yes\"\n- name: REDIS_HOST\nvalue: \"svc-bunkerweb-redis.default.svc.cluster.local\"\nlivenessProbe:\nexec:\ncommand:\n- /usr/share/bunkerweb/helpers/healthcheck.sh\ninitialDelaySeconds: 30\nperiodSeconds: 5\ntimeoutSeconds: 1\nfailureThreshold: 3\nreadinessProbe:\nexec:\ncommand:\n- /usr/share/bunkerweb/helpers/healthcheck.sh\ninitialDelaySeconds: 30\nperiodSeconds: 1\ntimeoutSeconds: 1\nfailureThreshold: 3\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-controller\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-controller\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-controller\nspec:\nserviceAccountName: sa-bunkerweb\ncontainers:\n- name: bunkerweb-controller\nimage: bunkerity/bunkerweb-autoconf:1.5.1\nimagePullPolicy: Always\nenv:\n- name: KUBERNETES_MODE\nvalue: \"yes\"\n- name: \"DATABASE_URI\"\nvalue: \"mariadb+pymysql://bunkerweb:changeme@svc-bunkerweb-db:3306/db\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-scheduler\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-scheduler\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-scheduler\nspec:\nserviceAccountName: sa-bunkerweb\ncontainers:\n- name: bunkerweb-scheduler\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nimagePullPolicy: Always\nenv:\n- name: KUBERNETES_MODE\nvalue: \"yes\"\n- name: \"DATABASE_URI\"\nvalue: \"mariadb+pymysql://bunkerweb:changeme@svc-bunkerweb-db:3306/db\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-redis\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-redis\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-redis\nspec:\ncontainers:\n- name: bunkerweb-redis\nimage: redis:7-alpine\nimagePullPolicy: Always\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-db\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-db\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-db\nspec:\ncontainers:\n- name: bunkerweb-db\nimage: mariadb:10.10\nimagePullPolicy: Always\nenv:\n- name: MYSQL_RANDOM_ROOT_PASSWORD\nvalue: \"yes\"\n- name: \"MYSQL_DATABASE\"\nvalue: \"db\"\n- name: \"MYSQL_USER\"\nvalue: \"bunkerweb\"\n- name: \"MYSQL_PASSWORD\"\nvalue: \"changeme\"\nvolumeMounts:\n- mountPath: \"/var/lib/mysql\"\nname: vol-db\nvolumes:\n- name: vol-db\npersistentVolumeClaim:\nclaimName: pvc-bunkerweb\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-bunkerweb\nspec:\nclusterIP: None\nselector:\napp: bunkerweb\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-bunkerweb-db\nspec:\ntype: ClusterIP\nselector:\napp: bunkerweb-db\nports:\n- name: sql\nprotocol: TCP\nport: 3306\ntargetPort: 3306\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-bunkerweb-redis\nspec:\ntype: ClusterIP\nselector:\napp: bunkerweb-redis\nports:\n- name: redis\nprotocol: TCP\nport: 6379\ntargetPort: 6379\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\nname: pvc-bunkerweb\nspec:\naccessModes:\n- ReadWriteOnce\nresources:\nrequests:\nstorage: 5Gi\n</code></pre> <p>Once the BunkerWeb Kubernetes stack is successfully set up and operational (refer to the autoconf logs for detailed information), you can proceed with deploying web applications within the cluster and declaring your Ingress resource.</p> <p>It is important to note that the BunkerWeb settings need to be specified as annotations for the Ingress resource. For the domain part, please use the special value \"bunkerweb.io\". By including the appropriate annotations, you can configure BunkerWeb accordingly for the Ingress resource.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\nname: my-ingress\nannotations:\nbunkerweb.io/MY_SETTING: \"value\"\nbunkerweb.io/www.example.com_MY_SETTING: \"value\"\nspec:\nrules:\n- host: www.example.com\nhttp:\npaths:\n- path: /\npathType: Prefix\nbackend:\nservice:\nname: svc-my-app\nport:\nnumber: 8000\n...\n</code></pre>"},{"location":"integrations/#linux","title":"Linux","text":"Linux integration <p>Supported Linux distributions for BunkerWeb (amd64/x86_64 and arm64/aarch64 architectures) include:</p> <ul> <li>Debian 11 \"Bullseye\"</li> <li>Ubuntu 22.04 \"Jammy\"</li> <li>Fedora 38</li> <li>Red Hat Enterprise Linux (RHEL) 8.7</li> </ul> <p>Please ensure that you have NGINX 1.24.0 installed before installing BunkerWeb. For all distributions, except Fedora, it is mandatory to use prebuilt packages from the official NGINX repository. Compiling NGINX from source or using packages from different repositories will not work with the official prebuilt packages of BunkerWeb. However, you have the option to build BunkerWeb from source.</p> <p>To simplify the installation process, Linux package repositories for BunkerWeb are available on PackageCloud. They provide a bash script that automatically adds and trusts the repository. You can follow the provided script for automatic setup, or opt for manual installation instructions if you prefer.</p> DebianUbuntuFedoraRedHat <p>The first step is to add NGINX official repository :</p> <pre><code>sudo apt install -y curl gnupg2 ca-certificates lsb-release debian-archive-keyring &amp;&amp; \\\ncurl https://nginx.org/keys/nginx_signing.key | gpg --dearmor \\\n| sudo tee /usr/share/keyrings/nginx-archive-keyring.gpg &gt;/dev/null &amp;&amp; \\\necho \"deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \\\nhttp://nginx.org/packages/debian `lsb_release -cs` nginx\" \\\n| sudo tee /etc/apt/sources.list.d/nginx.list\n</code></pre> <p>You should now be able to install NGINX 1.24.0 :</p> <pre><code>sudo apt update &amp;&amp; \\\nsudo apt install -y nginx=1.24.0-1~$(lsb_release -cs)\n</code></pre> <p>And finally install BunkerWeb 1.5.1 :</p> <pre><code>curl -s https://packagecloud.io/install/repositories/bunkerity/bunkerweb/script.deb.sh | sudo bash &amp;&amp; \\\nsudo apt update &amp;&amp; \\\nsudo apt install -y bunkerweb=1.5.1\n</code></pre> <p>To prevent upgrading NGINX and/or BunkerWeb packages when executing <code>apt upgrade</code>, you can use the following command :</p> <pre><code>sudo apt-mark hold nginx bunkerweb\n</code></pre> <p>The first step is to add NGINX official repository :</p> <pre><code>sudo apt install -y curl gnupg2 ca-certificates lsb-release ubuntu-keyring &amp;&amp; \\\ncurl https://nginx.org/keys/nginx_signing.key | gpg --dearmor \\\n| sudo tee /usr/share/keyrings/nginx-archive-keyring.gpg &gt;/dev/null &amp;&amp; \\\necho \"deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \\\nhttp://nginx.org/packages/ubuntu `lsb_release -cs` nginx\" \\\n| sudo tee /etc/apt/sources.list.d/nginx.list\n</code></pre> <p>You should now be able to install NGINX 1.24.0 :</p> <pre><code>sudo apt update &amp;&amp; \\\nsudo apt install -y nginx=1.24.0-1~jammy\n</code></pre> <p>And finally install BunkerWeb 1.5.1 :</p> <pre><code>curl -s https://packagecloud.io/install/repositories/bunkerity/bunkerweb/script.deb.sh | sudo bash &amp;&amp; \\\nsudo apt update &amp;&amp; \\\nsudo apt install -y bunkerweb=1.5.1\n</code></pre> <p>To prevent upgrading NGINX and/or BunkerWeb packages when executing <code>apt upgrade</code>, you can use the following command :</p> <pre><code>sudo apt-mark hold nginx bunkerweb\n</code></pre> <p>Fedora already provides NGINX 1.24.0 that we support :</p> <pre><code>sudo dnf install -y nginx-1.24.0\n</code></pre> <p>And finally install BunkerWeb 1.5.1 :</p> <pre><code>curl -s https://packagecloud.io/install/repositories/bunkerity/bunkerweb/script.rpm.sh | \\\nsed 's/yum install -y pygpgme --disablerepo='\\''bunkerity_bunkerweb'\\''/yum install -y python-gnupg/g' | \\\nsed 's/pypgpme_check=`rpm -qa | grep -qw pygpgme`/python-gnupg_check=`rpm -qa | grep -qw python-gnupg`/g' | sudo bash &amp;&amp; \\\nsudo dnf makecache &amp;&amp; \\\nsudo dnf install -y bunkerweb-1.5.1\n</code></pre> <p>To prevent upgrading NGINX and/or BunkerWeb packages when executing <code>dnf upgrade</code>, you can use the following command :</p> <pre><code>sudo dnf versionlock add nginx &amp;&amp; \\\nsudo dnf versionlock add bunkerweb\n</code></pre> <p>The first step is to add NGINX official repository. Create the following file at <code>/etc/yum.repos.d/nginx.repo</code> :</p> <pre><code>[nginx-stable]\nname=nginx stable repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=1\nenabled=1\ngpgkey=https://nginx.org/keys/nginx_signing.key\nmodule_hotfixes=true\n\n[nginx-mainline]\nname=nginx mainline repo\nbaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/\ngpgcheck=1\nenabled=0\ngpgkey=https://nginx.org/keys/nginx_signing.key\nmodule_hotfixes=true\n</code></pre> <p>You should now be able to install NGINX 1.24.0 :</p> <p><pre><code>sudo dnf install nginx-1.24.0\n</code></pre> And finally install BunkerWeb 1.5.1 :</p> <pre><code>  dnf install -y epel-release &amp;&amp; \\\ncurl -s https://packagecloud.io/install/repositories/bunkerity/bunkerweb/script.rpm.sh | sudo bash &amp;&amp; \\\nsudo dnf check-update &amp;&amp; \\\nsudo dnf install -y bunkerweb-1.5.1\n</code></pre> <p>To prevent upgrading NGINX and/or BunkerWeb packages when executing <code>dnf upgrade</code>, you can use the following command :</p> <pre><code>sudo dnf versionlock add nginx &amp;&amp; \\\nsudo dnf versionlock add bunkerweb\n</code></pre> <p>The configuration of BunkerWeb is done by editing the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>MY_SETTING_1=value1\nMY_SETTING_2=value2\n...\n</code></pre> <p>BunkerWeb is managed using systemctl :</p> <ul> <li>Check BunkerWeb status : <code>systemctl status bunkerweb</code></li> <li>Start it if it's stopped : <code>systemctl start bunkerweb</code></li> <li>Stop it if it's started : <code>systemctl stop bunkerweb</code></li> <li>And restart : <code>systemctl restart bunkerweb</code></li> </ul>"},{"location":"integrations/#ansible","title":"Ansible","text":"Ansible integration <p>Supported Linux distributions for BunkerWeb (amd64/x86_64 and arm64/aarch64 architectures) include:</p> <ul> <li>Debian 11 \"Bullseye\"</li> <li>Ubuntu 22.04 \"Jammy\"</li> <li>Fedora 38</li> <li>Red Hat Enterprise Linux (RHEL) 8.7</li> </ul> <p>To simplify the deployment and configuration process, Ansible can be used as an IT automation tool. Ansible enables you to configure systems, deploy software, and perform advanced IT tasks such as continuous deployments or zero downtime rolling updates.</p> <p>For BunkerWeb, there is a dedicated Ansible role available on Ansible Galaxy.</p> <p>To proceed with the BunkerWeb Ansible role setup, follow these steps:</p> <ol> <li> <p>Begin by creating an inventory file that lists the IP addresses or FQDNs of the remote systems you want to manage. You can either add this information to the <code>/etc/ansible/hosts</code> file or create a separate inventory file such as <code>inventory.yml</code>. Here's an example using a TOML format:</p> <pre><code>[mybunkers]\n192.0.2.50\n192.0.2.51\n192.0.2.52\n</code></pre> </li> <li> <p>Next, establish SSH connections to the managed nodes by adding your public SSH keys to the <code>authorized_keys</code> file on each remote system. Verify that you can successfully connect to the nodes using SSH.</p> </li> <li> <p>Create a playbook file, such as <code>playbook.yml</code>, which will define the desired configuration using the BunkerWeb Ansible role. Here's an example playbook configuration:</p> <pre><code>---\n- hosts: all\nbecome: true\nroles:\n- bunkerity.bunkerweb\n</code></pre> </li> <li> <p>Execute the playbook using the <code>ansible-playbook</code> command, providing the inventory file and the playbook file as arguments. For example:</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> </li> </ol> <p>By running the playbook, Ansible will apply the BunkerWeb role to all the hosts specified in the inventory, setting up the desired configuration.</p> <p>the configuration of BunkerWeb is done by using specific role variables :</p> Name Type Description Default value <code>bunkerweb_version</code> string Version of BunkerWeb to install. <code>1.5.1</code> <code>nginx_version</code> string Version of NGINX to install. <code>1.24.0</code> <code>freeze_versions</code> boolean Prevent upgrade of BunkerWeb and NGINX when performing packages upgrades. <code>true</code> <code>variables_env</code> string Path of the variables.env file to configure BunkerWeb. <code>files/variables.env</code> <code>enable_ui</code> boolean Activate the web UI. <code>false</code> <code>custom_ui</code> string Path of the ui.env file to configure the web UI. <code>files/ui.env</code> <code>custom_configs_path</code> Dictionary Each entry is a path of the folder containing custom configurations. Keys are the type of custom configs : <code>http</code>, <code>server-http</code>, <code>modsec</code>, <code>modsec-crs</code> and <code>default-server-http</code> empty values <code>custom_www</code> string Path of the www directory to upload. empty value <code>custom_plugins</code> string Path of the plugins directory to upload. empty value <code>custom_www_owner</code> string Default owner for www files and folders. <code>nginx</code> <code>custom_www_group</code> string Default group for www files and folders. <code>nginx</code>"},{"location":"integrations/#vagrant","title":"Vagrant","text":"<p>List of supported providers :</p> <ul> <li>virtualbox </li> <li>libvirt</li> </ul> <p>Supported Base Images</p> <p>Please be aware that the provided Vagrant boxes are based exclusively on Ubuntu 22.04 \"Jammy\". While BunkerWeb supports other Linux distributions, the Vagrant setup currently only supports Ubuntu 22.04 as the base operating system. This ensures a consistent and reliable environment for users who want to deploy BunkerWeb using Vagrant.</p> <p>Similar to other BunkerWeb integrations, the Vagrant setup uses NGINX version 1.24.0. This specific version is required to ensure compatibility and smooth functioning with BunkerWeb. Additionally, the Vagrant box includes PHP pre-installed, providing a ready-to-use environment for hosting PHP-based applications alongside BunkerWeb.</p> <p>By using the provided Vagrant box based on Ubuntu 22.04 \"Jammy\", you benefit from a well-configured and integrated setup, allowing you to focus on developing and securing your applications with BunkerWeb without worrying about the underlying infrastructure.</p> <p>Here are the steps to install BunkerWeb using Vagrant on Ubuntu with the supported virtualization providers (VirtualBox, and libvirt):</p> <ol> <li>Make sure you have Vagrant and one of the supported virtualization providers (VirtualBox or libvirt) installed on your system.</li> <li>There are two ways to install the Vagrant box with BunkerWeb: either by using a provided Vagrantfile to configure your virtual machine or by creating a new box based on the existing BunkerWeb Vagrant box, offering you flexibility in how you set up your development environment.</li> </ol> VagrantfileNew Vagrant Box <pre><code>Vagrant.configure(\"2\") do |config|\nconfig.vm.box = \"bunkerity/bunkerweb\"\nend\n</code></pre> <p>Depending on the virtualization provider you choose, you may need to install additional plugins:</p> <ul> <li>For libvirt, install the <code>vagrant-libvirt plugin</code>. For more information, see the Vagrant documentation.</li> <li>For VirtualBox, install the <code>vagrant-vbguest</code> plugin. For more information, see the Vagrant documentation.</li> </ul> <pre><code>vagrant init bunkerity/bunkerweb\n</code></pre> <p>Depending on the virtualization provider you choose, you may need to install additional plugins:</p> <ul> <li>For libvirt, install the <code>vagrant-libvirt plugin</code>. For more information, see the Vagrant documentation.</li> <li>For VirtualBox, install the <code>vagrant-vbguest</code> plugin. For more information, see the Vagrant documentation.</li> </ul> <p>After installing the necessary plugins for your chosen virtualization provider, run the following command to start the virtual machine and install BunkerWeb:</p> <pre><code>vagrant up --provider=virtualbox # or --provider=libvirt\n</code></pre> <p>Finally, to access the virtual machine using SSH, execute the following command:</p> <pre><code>vagrant ssh\n</code></pre> <p>Example Vagrantfile</p> <p>Here is an example <code>Vagrantfile</code> for installing BunkerWeb on Ubuntu 22.04 \"Jammy\" using the different supported virtualization providers:</p> <pre><code>Vagrant.configure(\"2\") do |config|\n# Ubuntu 22.04 \"Jammy\"\nconfig.vm.box = \"bunkerity/bunkerweb\"\n# Uncomment the desired virtualization provider\n# For VirtualBox (default)\nconfig.vm.provider \"virtualbox\"\n# For libvirt\n# config.vm.provider \"libvirt\"\nend\n</code></pre>"},{"location":"migrating/","title":"Migrating from 1.4.X","text":"<p>Read this if you were a 1.4.X user</p> <p>A lot of things changed since the 1.4.X releases. Container-based integrations stacks contain more services but, trust us, fundamental principles of BunkerWeb are still there. You will find ready to use boilerplates for various integrations in the misc/integrations folder of the repository.</p>"},{"location":"migrating/#scheduler","title":"Scheduler","text":"<p>Back to the 1.4.X releases, jobs (like Let's Encrypt certificate generation/renewal or blacklists download) were executed in the same container as BunkerWeb. For the purpose of separation of concerns, we decided to create a separate service which is now responsible for managing jobs.</p> <p>Called Scheduler, this service also generates the final configuration used by BunkerWeb and acts as an intermediary between autoconf and BunkerWeb. In other words, the scheduler is the brain of the BunkerWeb 1.5.X stack.</p> <p>You will find more information about the scheduler here.</p>"},{"location":"migrating/#database","title":"Database","text":"<p>BunkerWeb configuration is no more stored in a plain file (located at <code>/etc/nginx/variables.env</code> if you didn't know it). That's it, we now support a fully-featured database as a backend to store settings, cache, custom configs, ... \ud83e\udd73</p> <p>Using a real database offers many advantages :</p> <ul> <li>Backup of the current configuration</li> <li>Usage with multiple services (scheduler, web UI, ...)</li> <li>Upgrade to a new BunkerWeb version</li> </ul> <p>Please note that we actually support, SQLite, MySQL, MariaDB and PostgreSQL as backends.</p> <p>You will find more information about the database here.</p>"},{"location":"migrating/#redis","title":"Redis","text":"<p>When BunkerWeb 1.4.X was used in cluster mode (Swarm or Kubernetes integrations), data were not shared among the nodes. For example, if an attacker was banned via the \"bad behavior\" feature on a specific node, he could still connect to the other nodes.</p> <p>Security is not the only reason to have a shared data store for clustered integrations, caching is also another one. We can now store results of time-consuming operations like (reverse) dns lookups so they are available for other nodes.</p> <p>We actually support Redis as a backend for the shared data store.</p> <p>See the list of redis settings and the corresponding documentation of your integration for more information.</p>"},{"location":"migrating/#default-values-and-new-settings","title":"Default values and new settings","text":"<p>The default value of some settings have changed and we have added many other settings, we recommend you read the security tuning and settings sections of the documentation.</p>"},{"location":"plugins/","title":"Plugins","text":"<p>BunkerWeb comes with a plugin system making it possible to easily add new features. Once a plugin is installed, you can manage it using additional settings defined by the plugin.</p>"},{"location":"plugins/#official-plugins","title":"Official plugins","text":"<p>Here is the list of \"official\" plugins that we maintain (see the bunkerweb-plugins repository for more information) :</p> Name Version Description Link ClamAV 1.1 Automatically scans uploaded files with the ClamAV antivirus engine and denies the request when a file is detected as malicious. bunkerweb-plugins/clamav Coraza 1.1 Inspect requests using a the Coraza WAF (alternative of ModSecurity). bunkerweb-plugins/coraza CrowdSec 1.1 CrowdSec bouncer for BunkerWeb. bunkerweb-plugins/crowdsec Discord 1.1 Send security notifications to a Discord channel using a Webhook. bunkerweb-plugins/discord Slack 1.1 Send security notifications to a Slack channel using a Webhook. bunkerweb-plugins/slack VirusTotal 1.1 Automatically scans uploaded files with the VirusTotal API and denies the request when a file is detected as malicious. bunkerweb-plugins/virustotal WebHook 1.1 Send security notifications to a custom HTTP endpoint using a Webhook. bunkerweb-plugins/webhook"},{"location":"plugins/#how-to-use-a-plugin","title":"How to use a plugin","text":""},{"location":"plugins/#automatic","title":"Automatic","text":"<p>If you want to quickly install external plugins, you can use the <code>EXTERNAL_PLUGIN_URLS</code> setting. It takes a list of URLs, separated with space, pointing to compressed (zip format) archive containing one or more plugin(s).</p> <p>You can use the following value if you want to automatically install the official plugins : <code>EXTERNAL_PLUGIN_URLS=https://github.com/bunkerity/bunkerweb-plugins/archive/refs/tags/v1.1.zip</code></p>"},{"location":"plugins/#manual","title":"Manual","text":"<p>The first step is to install the plugin by putting the plugin files inside the corresponding <code>plugins</code> data folder, the procedure depends on your integration :</p> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When using the Docker integration, plugins must be written to the volume mounted on <code>/data/plugins</code> into the scheduler container.</p> <p>The first thing to do is to create the plugins folder :</p> <pre><code>mkdir -p ./bw-data/plugins\n</code></pre> <p>Then, you can drop the plugins of your choice into that folder :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb-plugins &amp;&amp; \\\ncp -rp ./bunkerweb-plugins/* ./bw-data/plugins\n</code></pre> <p>Because the scheduler runs as an unprivileged user with UID and GID 101, you will need to edit the permissions :</p> <pre><code>chown -R 101:101 ./bw-data\n</code></pre> <p>Then you can mount the volume when starting your Docker stack :</p> <pre><code>version: '3.5'\nservices:\n...\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nvolumes:\n- ./bw-data:/data\n...\n</code></pre> <p>When using the Docker autoconf integration, plugins must be written to the volume mounted on <code>/data/plugins</code> into the scheduler container.</p> <p>The first thing to do is to create the plugins folder :</p> <pre><code>mkdir -p ./bw-data/plugins\n</code></pre> <p>Then, you can drop the plugins of your choice into that folder :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb-plugins &amp;&amp; \\\ncp -rp ./bunkerweb-plugins/* ./bw-data/plugins\n</code></pre> <p>Because the scheduler runs as an unprivileged user with UID and GID 101, you will need to edit the permissions :</p> <pre><code>chown -R 101:101 ./bw-data\n</code></pre> <p>Then you can mount the volume when starting your Docker stack :</p> <pre><code>version: '3.5'\nservices:\n...\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nvolumes:\n- ./bw-data:/data\n...\n</code></pre> <p>When using the Swarm integration, plugins must be written to the volume mounted on <code>/data/plugins</code> into the scheduler container.</p> <p>Swarm volume</p> <p>Configuring a Swarm volume that will persist when the scheduler service is running on different nodes is not covered is in this documentation. We will assume that you have a shared folder mounted on <code>/shared</code> accross all nodes.</p> <p>The first thing to do is to create the plugins folder :</p> <pre><code>mkdir -p /shared/bw-plugins\n</code></pre> <p>Then, you can drop the plugins of your choice into that folder :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb-plugins &amp;&amp; \\\ncp -rp ./bunkerweb-plugins/* /shared/bw-plugins\n</code></pre> <p>Because the scheduler runs as an unprivileged user with UID and GID 101, you will need to edit the permissions :</p> <pre><code>chown -R 101:101 /shared/bw-plugins\n</code></pre> <p>Then you can mount the volume when starting your Swarm stack :</p> <pre><code>version: '3.5'\nservices:\n...\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nvolumes:\n- /shared/bw-plugins:/data/plugins\n...\n</code></pre> <p>When using the Kubernetes integration, plugins must be written to the volume mounted on <code>/data/plugins</code> into the scheduler container.</p> <p>The fist thing to do is to declare a PersistentVolumeClaim that will contain our plugins data :</p> <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\nname: pvc-bunkerweb-plugins\nspec:\naccessModes:\n- ReadWriteOnce\nresources:\nrequests:\nstorage: 5Gi\n</code></pre> <p>You can now add the volume mount and an init containers to automatically provision the volume :</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-scheduler\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-scheduler\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-scheduler\nspec:\nserviceAccountName: sa-bunkerweb\ncontainers:\n- name: bunkerweb-scheduler\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nimagePullPolicy: Always\nenv:\n- name: KUBERNETES_MODE\nvalue: \"yes\"\n- name: \"DATABASE_URI\"\nvalue: \"mariadb+pymysql://bunkerweb:changeme@svc-bunkerweb-db:3306/db\"\nvolumeMounts:\n- mountPath: \"/data/plugins\"\nname: vol-plugins\ninitContainers:\n- name: bunkerweb-scheduler-init\nimage: alpine/git\ncommand: [\"/bin/sh\", \"-c\"]\nargs: [\"git clone https://github.com/bunkerity/bunkerweb-plugins /data/plugins &amp;&amp; chown -R 101:101 /data/plugins\"]\nvolumeMounts:\n- mountPath: \"/data/plugins\"\nname: vol-plugins\nvolumes:\n- name: vol-plugins\npersistentVolumeClaim:\nclaimName: pvc-bunkerweb-plugins\n</code></pre> <p>When using the Linux integration, plugins must be written to the <code>/etc/bunkerweb/plugins</code> folder :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb-plugins &amp;&amp; \\\ncp -rp ./bunkerweb-plugins/* /etc/bunkerweb/plugins &amp;&amp; \\\nchown -R nginx:nginx /etc/bunkerweb/plugins\n</code></pre> <p>When using the Ansible integration, you can use the <code>plugins</code> variable to set a local folder containing your plugins that will be copied to your BunkerWeb instances.</p> <p>Let's assume that you have plugins inside the <code>bunkerweb-plugins</code> folder :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb-plugins\n</code></pre> <p>In your Ansible inventory, you can use the <code>plugins</code> variable to set the path of plugins folder :</p> <pre><code>[mybunkers]\n192.168.0.42 ... custom_plugins=\"{{ playbook_dir }}/bunkerweb-plugins\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- custom_plugins: \"{{ playbook_dir }}/bunkerweb-plugins\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>Run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>When using the Vagrant integration, plugins must be written to the <code>/etc/bunkerweb/plugins</code> folder (you will need to do a <code>vagrant ssh</code> first) :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb-plugins &amp;&amp; \\\ncp -rp ./bunkerweb-plugins/* /etc/bunkerweb/plugins\n</code></pre>"},{"location":"plugins/#writing-a-plugin","title":"Writing a plugin","text":"<p>Existing plugins</p> <p>If the documentation is not enough, you can have a look at the existing source code of official plugins and the core plugins (already included in BunkerWeb but they are plugins, technically speaking).</p> <p>The first step is to create a folder that will contain the plugin :</p> <pre><code>mkdir myplugin &amp;&amp; \\\ncd myplugin\n</code></pre>"},{"location":"plugins/#metadata","title":"Metadata","text":"<p>A file named plugin.json and written at the root of the plugin folder must contain metadata about the plugin. Here is an example :</p> <pre><code>{\n\"id\": \"myplugin\",\n\"name\": \"My Plugin\",\n\"description\": \"Just an example plugin.\",\n\"version\": \"1.0\",\n\"stream\": \"partial\",\n\"settings\": {\n\"DUMMY_SETTING\": {\n\"context\": \"multisite\",\n\"default\": \"1234\",\n\"help\": \"Here is the help of the setting.\",\n\"id\": \"dummy-id\",\n\"label\": \"Dummy setting\",\n\"regex\": \"^.*$\",\n\"type\": \"text\"\n}\n},\n\"jobs\": [\n{\n\"name\": \"my-job\",\n\"file\": \"my-job.py\",\n\"every\": \"hour\"\n}\n]\n}\n</code></pre> <p>Here are the details of the fields :</p> Field Mandatory Type Description <code>id</code> yes string Internal ID for the plugin : must be unique among other plugins (including \"core\" ones) and contain only lowercase chars. <code>name</code> yes string Name of your plugin. <code>description</code> yes string Description of your plugin. <code>version</code> yes string Version of your plugin. <code>stream</code> yes string Information about stream support : <code>no</code>, <code>yes</code> or <code>partial</code>. <code>settings</code> yes dict List of the settings of your plugin. <code>jobs</code> no list List of the jobs of your plugin. <p>Each setting has the following fields (the key is the ID of the settings used in a configuration) :</p> Field Mandatory Type Description <code>context</code> yes string Context of the setting : <code>multisite</code> or <code>global</code>. <code>default</code> yes string The default value of the setting. <code>help</code> yes string Help text about the plugin (shown in web UI). <code>id</code> yes string Internal ID used by the web UI for HTML elements. <code>label</code> yes string Label shown by the web UI. <code>regex</code> yes string The regex used to validate the value provided by the user. <code>type</code> yes string The type of the field : <code>text</code>, <code>check</code>, <code>select</code> or <code>password</code>. <code>multiple</code> no string Unique ID to group multiple settings with numbers as suffix. <code>select</code> no list List of possible string values when <code>type</code> is <code>select</code>. <p>Each job has the following fields :</p> Field Mandatory Type Description <code>name</code> yes string Name of the job. <code>file</code> yes string Name of the file inside the jobs folder. <code>every</code> yes string Job scheduling frequency : <code>minute</code>, <code>hour</code>, <code>day</code>, <code>week</code> or <code>once</code> (no frequency, only once before (re)generating the configuration)."},{"location":"plugins/#configurations","title":"Configurations","text":"<p>You can add custom NGINX configurations by adding a folder named confs with content similar to the custom configurations. Each subfolder inside the confs will contain jinja2 templates that will be generated and loaded at the corresponding context (<code>http</code>, <code>server-http</code>, <code>default-server-http</code>, <code>stream</code> and <code>server-stream</code>).</p> <p>Here is an example for a configuration template file inside the confs/server-http folder named example.conf :</p> <pre><code>location /setting {\n    default_type 'text/plain';\n    content_by_lua_block {\n        ngx.say('{{ DUMMY_SETTING }}')\n    }\n}\n</code></pre> <p><code>{{ DUMMY_SETTING }}</code> will be replaced by the value of the <code>DUMMY_SETTING</code> chosen by the user of the plugin.</p>"},{"location":"plugins/#lua","title":"LUA","text":""},{"location":"plugins/#main-script","title":"Main script","text":"<p>Under the hood, BunkerWeb is using the NGINX LUA module to execute code within NGINX. Plugins that need to execute code must provide a lua file at the root directory of the plugin folder using the <code>id</code> value of plugin.json as its name. Here is an example named myplugin.lua :</p> <pre><code>local class     = require \"middleclass\"\nlocal plugin    = require \"bunkerweb.plugin\"\nlocal utils     = require \"bunkerweb.utils\"\n\n\nlocal myplugin = class(\"myplugin\", plugin)\n\n\nfunction myplugin:initialize()\n    plugin.initialize(self, \"myplugin\")\n    self.dummy = \"dummy\"\nend\n\nfunction myplugin:init()\n    self.logger:log(ngx.NOTICE, \"init called\")\n    return self:ret(true, \"success\")\nend\n\nfunction myplugin:set()\n    self.logger:log(ngx.NOTICE, \"set called\")\n    return self:ret(true, \"success\")\nend\n\nfunction myplugin:access()\n    self.logger:log(ngx.NOTICE, \"access called\")\n    return self:ret(true, \"success\")\nend\n\nfunction myplugin:log()\n    self.logger:log(ngx.NOTICE, \"log called\")\n    return self:ret(true, \"success\")\nend\n\nfunction myplugin:log_default()\n    self.logger:log(ngx.NOTICE, \"log_default called\")\n    return self:ret(true, \"success\")\nend\n\nfunction myplugin:preread()\n    self.logger:log(ngx.NOTICE, \"preread called\")\n    return self:ret(true, \"success\")\nend\n\nfunction myplugin:log_stream()\n    self.logger:log(ngx.NOTICE, \"log_stream called\")\n    return self:ret(true, \"success\")\nend\n\nreturn myplugin\n</code></pre> <p>The declared functions are automatically called during specific contexts. Here are the details of each function :</p> Function Context Description Return value <code>init</code> init_by_lua Called when NGINX just started or received a reload order. the typical use case is to prepare any data that will be used by your plugin. <code>ret</code>, <code>msg</code><ul><li><code>ret</code> (boolean) : true if no error or else false</li><li><code>msg</code> (string) : success or error message</li></ul> <code>set</code> set_by_lua Called before each request received by the server.The typical use case is for computing before access phase. <code>ret</code>, <code>msg</code><ul><li><code>ret</code> (boolean) : true if no error or else false</li><li><code>msg</code> (string) : success or error message</li></ul> <code>access</code> access_by_lua Called on each request received by the server. The typical use case is to do the security checks here and deny the request if needed. <code>ret</code>, <code>msg</code>,<code>status</code>,<code>redirect</code><ul><li><code>ret</code> (boolean) : true if no error or else false</li><li><code>msg</code> (string) : success or error message</li><li><code>status</code> (number) : interrupt current process and return HTTP status</li><li><code>redirect</code> (URL) : if set will redirect to given URL</li></ul> <code>log</code> log_by_lua Called when a request has finished (and before it gets logged to the access logs). The typical use case is to make stats or compute counters for example. <code>ret</code>, <code>msg</code><ul><li><code>ret</code> (boolean) : true if no error or else false</li><li><code>msg</code> (string) : success or error message</li></ul> <code>log_default</code> log_by_lua Same as <code>log</code> but only called on the default server. <code>ret</code>, <code>msg</code><ul><li><code>ret</code> (boolean) : true if no error or else false</li><li><code>msg</code> (string) : success or error message</li></ul> <code>preread</code> preread_by_lua Similar to the <code>access</code> function but for stream mode. <code>ret</code>, <code>msg</code>,<code>status</code><ul><li><code>ret</code> (boolean) : true if no error or else false</li><li><code>msg</code> (string) : success or error message</li><li><code>status</code> (number) : interrupt current process and return status</li></ul> <code>log_stream</code> log_by_lua Similar to the <code>log</code> function but for stream mode. <code>ret</code>, <code>msg</code><ul><li><code>ret</code> (boolean) : true if no error or else false</li><li><code>msg</code> (string) : success or error message</li></ul>"},{"location":"plugins/#libraries","title":"Libraries","text":"<p>All directives from NGINX LUA module and are available and NGINX stream LUA module. On top of that, you can use the LUA libraries included within BunkerWeb : see this script for the complete list.</p> <p>If you need additional libraries, you can put them in the root folder of the plugin and access them by prefixing them with your plugin ID. Here is an example file named mylibrary.lua :</p> <pre><code>local _M = {}\n\n_M.dummy = function ()\n    return \"dummy\"\nend\n\nreturn _M\n</code></pre> <p>And here is how you can use it from the myplugin.lua file :</p> <pre><code>local mylibrary = require \"myplugin.mylibrary\"\n\n...\n\nmylibrary.dummy()\n\n...\n</code></pre>"},{"location":"plugins/#helpers","title":"Helpers","text":"<p>Some helpers modules provide common helpful helpers :</p> <ul> <li><code>self.variables</code> : allows to access and store plugins' attributes</li> <li><code>self.logger</code> : print logs</li> <li><code>bunkerweb.utils</code> : various useful functions</li> <li><code>bunkerweb.datastore</code> : access the global shared data on one instance (key/value store)</li> <li><code>bunkerweb.clusterstore</code> : access a Redis data store shared beetween BunkerWeb instances (key/value store)</li> </ul> <p>To access the functions, you first need to require the modules :</p> <pre><code>local utils       = require \"bunkerweb.utils\"\nlocal datastore   = require \"bunkerweb.datastore\"\nlocal clustestore = require \"bunkerweb.clustertore\"\n</code></pre> <p>Retrieve a setting value :</p> <pre><code>local myvar = self.variables[\"DUMMY_SETTING\"]\nif not myvar then\n    self.logger:log(ngx.ERR, \"can't retrieve setting DUMMY_SETTING\")\nelse\n    self.logger:log(ngx.NOTICE, \"DUMMY_SETTING = \" .. value)\nend\n</code></pre> <p>Store something in the local cache :</p> <pre><code>local ok, err = self.datastore:set(\"plugin_myplugin_something\", \"somevalue\")\nif not ok then\n    self.logger:log(ngx.ERR, \"can't save plugin_myplugin_something into datastore : \" .. err)\nelse\n    self.logger:log(ngx.NOTICE, \"successfully saved plugin_myplugin_something into datastore\")\nend\n</code></pre> <p>Check if an IP address is global :</p> <pre><code>local ret, err = utils.ip_is_global(ngx.ctx.bw.remote_addr)\nif ret == nil then\n    self.logger:log(ngx.ERR, \"error while checking if IP \" .. ngx.ctx.bw.remote_addr .. \" is global or not : \" .. err)\nelseif not ret then\n    self.logger:log(ngx.NOTICE, \"IP \" .. ngx.ctx.bw.remote_addr .. \" is not global\")\nelse\n    self.logger:log(ngx.NOTICE, \"IP \" .. ngx.ctx.bw.remote_addr .. \" is global\")\nend\n</code></pre> <p>More examples</p> <p>If you want to see the full list of available functions, you can have a look at the files present in the lua directory of the repository.</p>"},{"location":"plugins/#jobs","title":"Jobs","text":"<p>BunkerWeb uses an internal job scheduler for periodic tasks like renewing certificates with certbot, downloading blacklists, downloading MMDB files, ... You can add tasks of your choice by putting them inside a subfolder named jobs and listing them in the plugin.json metadata file. Don't forget to add the execution permissions for everyone to avoid any problems when a user is cloning and installing your plugin.</p>"},{"location":"plugins/#plugin-page","title":"Plugin page","text":"<p>Plugin pages are used to display information about your plugin and interact with the user inside the plugins section of the web UI.</p> <p>Everything related to the web UI is located inside a subfolder named ui at the root directory of your plugin. A template file named template.html and located inside the ui subfolder contains the client code and logic to display your page. Another file named actions.py and also located inside the ui subfolder contains code that will be executed when the user is interacting with your page (filling a form for example).</p> <p>Jinja 2 template</p> <p>The template.html file is a Jinja2 template, please refer to the Jinja2 documentation if needed.</p> <p>A plugin page can have a form that is used to submit data to the plugin. To get the values of the form, you need to put a actions.py file in the ui folder. Inside the file, you must define a function that has the same name as the plugin. This function will be called when the form is submitted. You can then use the request object (from the Flask library) to get the values of the form. The form's action must finish with /plugins/&lt;plugin_id&gt;. The helper function <code>url_for</code> will generate for you the prefix of the URL : <code>{{ url_for('plugins') }}/plugin_id</code>.</p> <p>If you want to display variables generated from your actions.py in your template file, you can return a dictionary with variables name as keys and variables value as values. Here is dummy example where we return a single variable :</p> <pre><code>def myplugin() :\n    return {\"foo\": \"bar\"}\n</code></pre> <p>And we display it in the template.html file : <pre><code>{% if foo %}\nContent of foo is : {{ foo }}.\n{% endif %}\n</code></pre></p> <p>Please note that every form submission is protected via a CSRF token, you will need to include the following snippet into your forms : <pre><code>&lt;input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\" /&gt;\n</code></pre></p> <p>Retrieving user submitted data is pretty simple, thanks to the request module provided by Flask :</p> <pre><code>from flask import request\n\ndef myplugin() :\n    my_form_value = request.form[\"my_form_input\"]\n</code></pre> <p>Python libraries</p> <p>You can use Python libraries that are already available like : <code>Flask</code>, <code>Flask-Login</code>, <code>Flask-WTF</code>, <code>beautifulsoup4</code>, <code>docker</code>, <code>Jinja2</code>, <code>python-magic</code> and <code>requests</code>. To see the full list, you can have a look at the Web UI requirements.txt. If you need external libraries, you can install them inside the ui folder of your plugin and then use the classical import directive.</p>"},{"location":"quickstart-guide/","title":"Quickstart guide","text":"<p>Prerequisites</p> <p>We assume that you're already familiar with the core concepts and you have followed the integrations instructions for your environment.</p> <p>Going further<p>To demonstrate the use of BunkerWeb, we will deploy a dummy \"Hello World\" web application as an example. See the examples folder of the repository to get real-world examples.</p> </p>"},{"location":"quickstart-guide/#protect-http-applications","title":"Protect HTTP applications","text":"<p>Protecting existing web applications already accessible with the HTTP(S) protocol is the main goal of BunkerWeb : it will act as a classical reverse proxy with extra security features.</p> <p>The following settings can be used :</p> <ul> <li><code>USE_REVERSE_PROXY</code> : enable/disable reverse proxy mode</li> <li><code>REVERSE_PROXY_URL</code> : the public path prefix</li> <li><code>REVERSE_PROXY_HOST</code> : (internal) address of the proxied web application</li> </ul> <p>You will find more settings about reverse proxy in the settings section of the documentation.</p>"},{"location":"quickstart-guide/#single-application","title":"Single application","text":"DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When using Docker integration, the easiest way of protecting an existing application is to add the web service in the <code>bw-services</code> network :</p> <pre><code>version: \"3.5\"\n\nservices:\n\nmyapp:\nimage: tutum/hello-world\nnetworks:\n- bw-services\n\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080\n- 443:8443\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- SERVER_NAME=www.example.com\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\n- USE_REVERSE_PROXY=yes\n- REVERSE_PROXY_URL=/\n- REVERSE_PROXY_HOST=http://myapp\nnetworks:\n- bw-universe\n- bw-services\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nvolumes:\n- bw-data:/data\nenvironment:\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>We will assume that you already have the Docker autoconf integration stack running on your machine and connected to a network called <code>bw-services</code> so you can connect your existing application and configure BunkerWeb with labels :</p> <pre><code>version: '3.5'\n\nservices:\nmyapp:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp\nlabels:\n- \"bunkerweb.SERVER_NAME=www.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>We will assume that you already have the Swarm integration stack running on your cluster and connected to a network called <code>bw-services</code> so you can connect your existing application and configure BunkerWeb with labels :</p> <pre><code>version: \"3\"\n\nservices:\nmyapp:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=www.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>We will assume that you already have the Kubernetes integration stack running on your cluster.</p> <p>Let's assume that you have a typical Deployment with a Service to access the web application from within the cluster :</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: app\nlabels:\napp: app\nspec:\nreplicas: 1\nselector:\nmatchLabels:\napp: app\ntemplate:\nmetadata:\nlabels:\napp: app\nspec:\ncontainers:\n- name: app\nimage: tutum/hello-world\nports:\n- containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-app\nspec:\nselector:\napp: app\nports:\n- protocol: TCP\nport: 80\ntargetPort: 80\n</code></pre> <p>Here is the corresponding Ingress definition to serve and protect the web application :</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\nname: ingress\nannotations:\nbunkerweb.io/DUMMY_SETTING: \"value\"\nspec:\nrules:\n- host: www.example.com\nhttp:\npaths:\n- path: /\npathType: Prefix\nbackend:\nservice:\nname: svc-app\nport:\nnumber: 80\n</code></pre> <p>We will assume that you already have the Linux integration stack running on your machine.</p> <p>The following command will run a basic HTTP server on the port 8000 and deliver the files in the current directory :</p> <pre><code>python3 -m http.server -b 127.0.0.1\n</code></pre> <p>Configuration of BunkerWeb is done by editing the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nSERVER_NAME=www.example.com\nUSE_REVERSE_PROXY=yes\nREVERSE_PROXY_URL=/\nREVERSE_PROXY_HOST=http://127.0.0.1:8000\n</code></pre> <p>Let's check the status of BunkerWeb :</p> <pre><code>systemctl status bunkerweb\n</code></pre> <p>If it's already running, we can restart it :</p> <pre><code>systemctl restart bunkerweb\n</code></pre> <p>Otherwise, we will need to start it :</p> <pre><code>systemctl start bunkerweb\n</code></pre> <p>We will assume that you already have a service running and you want to use BunkerWeb as a reverse-proxy.</p> <p>The following command will run a basic HTTP server on the port 8000 and deliver the files in the current directory :</p> <pre><code>python3 -m http.server -b 127.0.0.1\n</code></pre> <p>Content of the <code>my_variables.env</code> configuration file :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nSERVER_NAME=www.example.com\nUSE_REVERSE_PROXY=yes\nREVERSE_PROXY_URL=/\nREVERSE_PROXY_HOST=http://127.0.0.1:8000\n</code></pre> <p>In your Ansible inventory, you can use the <code>variables_env</code> variable to set the path of configuration file :</p> <pre><code>[mybunkers]\n192.168.0.42 variables_env=\"{{ playbook_dir }}/my_variables.env\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- variables_env: \"{{ playbook_dir }}/my_variables.env\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>You can now run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>We will assume that you already have the Vagrant integration stack running on your machine.</p> <p>The following command will run a basic HTTP server on the port 8000 and deliver the files in the current directory :</p> <pre><code>python3 -m http.server -b 127.0.0.1\n</code></pre> <p>Configuration of BunkerWeb is done by editing the <code>/etc/bunkerweb/variables.env</code> file.</p> <p>Connect to your vagrant machine :</p> <pre><code>vagrant ssh\n</code></pre> <p>And then you can edit the <code>variables.env</code> file in your host machine like this :</p> <pre><code>SERVER_NAME=www.example.com\nHTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nUSE_REVERSE_PROXY=yes\nREVERSE_PROXY_URL=/\nREVERSE_PROXY_HOST=http://127.0.0.1:8000\n</code></pre> <p>Let's check the status of BunkerWeb :</p> <pre><code>systemctl status bunkerweb\n</code></pre> <p>If it's already running we can restart it :</p> <pre><code>systemctl restart bunkerweb\n</code></pre> <p>Otherwise, we will need to start it :</p> <pre><code>systemctl start bunkerweb\n</code></pre>"},{"location":"quickstart-guide/#multiple-applications","title":"Multiple applications","text":"<p>Testing</p> <p>To perform quick tests when multisite mode is enabled (and if you don't have the proper DNS entries set up for the domains) you can use curl with the HTTP Host header of your choice :</p> <pre><code>curl -H \"Host: app1.example.com\" http://ip-or-fqdn-of-server\n</code></pre> <p>If you are using HTTPS, you will need to play with SNI :</p> <pre><code>curl -H \"Host: app1.example.com\" --resolve example.com:443:ip-of-server https://example.com\n</code></pre> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When using Docker integration, the easiest way of protecting an existing application is to add the web service in the <code>bw-services network</code> :</p> <pre><code>version: \"3.5\"\n\nservices:\nmyapp1:\nimage: tutum/hello-world\nnetworks:\n- bw-services\n\nmyapp2:\nimage: tutum/hello-world\nnetworks:\n- bw-services\n\nmyapp3:\nimage: tutum/hello-world\nnetworks:\n- bw-services\n\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080\n- 443:8443\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\n- MULTISITE=yes\n- SERVER_NAME=app1.example.com app2.example.com app3.example.com\n- USE_REVERSE_PROXY=yes # Will be applied to all server config\n- REVERSE_PROXY_URL=/ # Will be applied to all server config\n- app1.example.com_REVERSE_PROXY_HOST=http://myapp1\n- app2.example.com_REVERSE_PROXY_HOST=http://myapp2\n- app3.example.com_REVERSE_PROXY_HOST=http://myapp3\nnetworks:\n- bw-universe\n- bw-services\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nvolumes:\n- bw-data:/data\nenvironment:\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>We will assume that you already have the Docker autoconf integration stack running on your machine and connected to a network called <code>bw-services</code> so you can connect your existing application and configure BunkerWeb with labels :</p> <pre><code>version: '3.5'\n\nservices:\nmyapp1:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp1\nlabels:\n- \"bunkerweb.SERVER_NAME=app1.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp1\"\n\nmyapp2:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp1\nlabels:\n- \"bunkerweb.SERVER_NAME=app2.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp2\"\n\nmyapp3:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp3\nlabels:\n- \"bunkerweb.SERVER_NAME=app3.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp3\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>We will assume that you already have the Swarm integration stack running on your cluster and connected to a network called <code>bw-services</code> so you can connect your existing application and configure BunkerWeb with labels :</p> <pre><code>version: \"3\"\n\nservices:\nmyapp1:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp1\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app1.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp1\"\n\nmyapp2:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp2\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app2.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp2\"\n\nmyapp3:\nimage: tutum/hello-world\nnetworks:\nbw-services:\naliases:\n- myapp3\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app3.example.com\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://myapp3\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>We will assume that you already have the Kubernetes integration stack running on your cluster.</p> <p>Let's assume that you have typical Deployments with a Service to access the web applications from within the cluster :</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: app1\nlabels:\napp: app1\nspec:\nreplicas: 1\nselector:\nmatchLabels:\napp: app1\ntemplate:\nmetadata:\nlabels:\napp: app1\nspec:\ncontainers:\n- name: app1\nimage: tutum/hello-world\nports:\n- containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-app1\nspec:\nselector:\napp: app1\nports:\n- protocol: TCP\nport: 80\ntargetPort: 80\n</code></pre> <p>Here is the corresponding Ingress definition to serve and protect the web applications :</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\nname: ingress\nannotations:\nbunkerweb.io/DUMMY_SETTING: \"value\"\nbunkerweb.io/app1.example.com_DUMMY_SETTING: \"value\"\nspec:\nrules:\n- host: app1.example.com\nhttp:\npaths:\n- path: /\npathType: Prefix\nbackend:\nservice:\nname: svc-app1\nport:\nnumber: 80\n- host: app2.example.com\nhttp:\npaths:\n- path: /\npathType: Prefix\nbackend:\nservice:\nname: svc-app2\nport:\nnumber: 80\n- host: app3.example.com\nhttp:\npaths:\n- path: /\npathType: Prefix\nbackend:\nservice:\nname: svc-app3\nport:\nnumber: 80\n</code></pre> <p>We will assume that you already have the Linux integration stack running on your machine.</p> <p>The following command will run a basic HTTP server on the port 8001 and deliver the files in the current directory (repeat it and change the port if you want to test BunkerWeb) :</p> <pre><code>python3 -m http.server -b 127.0.0.1 8001\n</code></pre> <p>Configuration of BunkerWeb is done by editing the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nMULTISITE=yes\nSERVER_NAME=app1.example.com app2.example.com app3.example.com\nUSE_REVERSE_PROXY=yes\nREVERSE_PROXY_URL=/\napp1.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8001\napp2.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8002\napp3.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8003\n</code></pre> <p>Let's check the status of BunkerWeb :</p> <pre><code>systemctl status bunkerweb\n</code></pre> <p>If it's already running, we can restart it :</p> <pre><code>systemctl restart bunkerweb\n</code></pre> <p>Otherwise, we will need to start it :</p> <pre><code>systemctl start bunkerweb\n</code></pre> <p>We will assume that you already have a service running and you want to use BunkerWeb as a reverse-proxy.</p> <p>The following command will run a basic HTTP server on the port 8001 and deliver the files in the current directory (repeat it and change the port if you want to test BunkerWeb) :</p> <pre><code>python3 -m http.server -b 127.0.0.1 8001\n</code></pre> <p>Content of the <code>my_variables.env</code> configuration file :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nMULTISITE=yes\nSERVER_NAME=app1.example.com app2.example.com app3.example.com\nUSE_REVERSE_PROXY=yes\nREVERSE_PROXY_URL=/\napp1.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8001\napp2.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8002\napp3.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8003\n</code></pre> <p>In your Ansible inventory, you can use the <code>variables_env</code> variable to set the path of configuration file :</p> <pre><code>[mybunkers]\n192.168.0.42 variables_env=\"{{ playbook_dir }}/my_variables.env\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- variables_env: \"{{ playbook_dir }}/my_variables.env\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>You can now run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>We will assume that you already have the Vagrant integration stack running on your machine.</p> <p>First of all, connect to your vagrant machine :</p> <pre><code>vagrant ssh\n</code></pre> <p>The following command will run a basic HTTP server on the port 8001 and deliver the files in the current directory (repeat it and change the port if you want to test BunkerWeb) :</p> <pre><code>python3 -m http.server -b 127.0.0.1 8001\n</code></pre> <p>And then you can edit the <code>variables.env</code> file in your host machine like this :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nMULTISITE=yes\nSERVER_NAME=app1.example.com app2.example.com app3.example.com\nUSE_REVERSE_PROXY=yes\nREVERSE_PROXY_URL=/\napp1.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8001\napp2.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8002\napp3.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:8003\n</code></pre> <p>Let's check the status of BunkerWeb :</p> <pre><code>systemctl status bunkerweb\n</code></pre> <p>If it's already running we can restart it :</p> <pre><code>systemctl restart bunkerweb\n</code></pre> <p>Otherwise, we will need to start it :</p> <pre><code>systemctl start bunkerweb\n</code></pre>"},{"location":"quickstart-guide/#behind-load-balancer-or-reverse-proxy","title":"Behind load balancer or reverse proxy","text":"<p>When BunkerWeb is itself behind a load balancer or a reverse proxy, you need to configure it so it can get the real IP address of the clients. If you don't, the security features will block the IP address of the load balancer or reverse proxy instead of the client's one.</p> <p>BunkerWeb actually supports two methods to retrieve the real IP address of the client :</p> <ul> <li>Using the <code>PROXY protocol</code></li> <li>Using a HTTP header like <code>X-Forwarded-For</code></li> </ul> <p>The following settings can be used :</p> <ul> <li><code>USE_REAL_IP</code> : enable/disable real IP retrieval</li> <li><code>USE_PROXY_PROTOCOL</code> : enable/disable PROXY protocol support</li> <li><code>REAL_IP_FROM</code> : list of trusted IP/network address allowed to send us the \"real IP\"</li> <li><code>REAL_IP_HEADER</code> : the HTTP header containing the real IP or special value <code>proxy_protocol</code> when using PROXY protocol</li> </ul> <p>You will find more settings about real IP in the settings section of the documentation.</p>"},{"location":"quickstart-guide/#http-header","title":"HTTP header","text":"<p>We will assume the following regarding the load balancers or reverse proxies (you will need to update the settings depending on your configuration) :</p> <ul> <li>They use the <code>X-Forwarded-For</code> header to set the real IP</li> <li>They have IPs in the <code>1.2.3.0/24</code> and <code>100.64.0.0/10</code> networks</li> </ul> <p>The following settings need to be set :</p> <pre><code>USE_REAL_IP=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=X-Forwarded-For\n</code></pre> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When starting the BunkerWeb container, you will need to add the settings :</p> <pre><code>mybunker:\nimage: bunkerity/bunkerweb:1.5.1\n...\nenvironment:\n- USE_REAL_IP=yes\n- REAL_IP_FROM=1.2.3.0/24 100.64.0.0/10\n- REAL_IP_HEADER=X-Forwarded-For\n...\n</code></pre> <p>Before running the Docker autoconf integration stack, you will need to add the settings for the BunkerWeb container :</p> <pre><code>mybunker:\nimage: bunkerity/bunkerweb:1.5.1\n...\nenvironment:\n- USE_REAL_IP=yes\n- REAL_IP_FROM=1.2.3.0/24 100.64.0.0/10\n- REAL_IP_HEADER=X-Forwarded-For\n...\n</code></pre> <p>Before running the Swarm integration stack, you will need to add the settings for the BunkerWeb service :</p> <pre><code>mybunker:\nimage: bunkerity/bunkerweb:1.5.1\n...\nenvironment:\n- USE_REAL_IP=yes\n- REAL_IP_FROM=1.2.3.0/24 100.64.0.0/10\n- REAL_IP_HEADER=X-Forwarded-For\n...\n</code></pre> <p>You will need to add the settings to the environment variables of the BunkerWeb containers (doing it using the ingress is not supported because you will get into trouble when using things like Let's Encrypt) :</p> <pre><code>apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\nname: bunkerweb\nspec:\n...\nspec:\ncontainers:\n- name: bunkerweb\n...\nenv:\n- name: USE_REAL_IP\nvalue: \"yes\"\n- name: REAL_IP_FROM\nvalue: \"1.2.3.0/24 100.64.0.0/10\"\n- name: REAL_IP_HEADER\nvalue: \"X-Forwarded-For\"\n...\n</code></pre> <p>You will need to add the settings to the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>...\nUSE_REAL_IP=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=X-Forwarded-For\n...\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p> <p>You will need to add the settings to your <code>my_variables.env</code> configuration file :</p> <pre><code>...\nUSE_REAL_IP=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=X-Forwarded-For\n...\n</code></pre> <p>In your Ansible inventory, you can use the <code>variables_env</code> variable to set the path of configuration file :</p> <pre><code>[mybunkers]\n192.168.0.42 variables_env=\"{{ playbook_dir }}/my_variables.env\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- variables_env: \"{{ playbook_dir }}/my_variables.env\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>Run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>You will need to add the settings to the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>...\nUSE_REAL_IP=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=X-Forwarded-For\n...\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p>"},{"location":"quickstart-guide/#proxy-protocol","title":"Proxy protocol","text":"<p>We will assume the following regarding the load balancers or reverse proxies (you will need to update the settings depending on your configuration) :</p> <ul> <li>They use the <code>PROXY protocol</code> v1 or v2 to set the real IP</li> <li>They have IPs in the <code>1.2.3.0/24</code> and <code>100.64.0.0/10</code> networks</li> </ul> <p>The following settings need to be set :</p> <pre><code>USE_REAL_IP=yes\nUSE_PROXY_PROTOCOL=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=proxy_protocol\n</code></pre> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When starting the BunkerWeb container, you will need to add the settings :</p> <pre><code>mybunker:\nimage: bunkerity/bunkerweb:1.5.1\n...\nenvironment:\n- USE_REAL_IP=yes\n- USE_PROXY_PROTOCOL=yes\n- REAL_IP_FROM=1.2.3.0/24 100.64.0.0/10\n- REAL_IP_HEADER=proxy_protocol\n...\n</code></pre> <p>Before running the Docker autoconf integration stack, you will need to add the settings for the BunkerWeb container :</p> <pre><code>mybunker:\nimage: bunkerity/bunkerweb:1.5.1\n...\nenvironment:\n- USE_REAL_IP=yes\n- USE_PROXY_PROTOCOL=yes\n- REAL_IP_FROM=1.2.3.0/24 100.64.0.0/10\n- REAL_IP_HEADER=proxy_protocol\n...\n</code></pre> <p>Before running the Swarm integration stack, you will need to add the settings for the BunkerWeb service :</p> <pre><code>mybunker:\nimage: bunkerity/bunkerweb:1.5.1\n...\nenvironment:\n- USE_REAL_IP=yes\n- USE_PROXY_PROTOCOL=yes\n- REAL_IP_FROM=1.2.3.0/24 100.64.0.0/10\n- REAL_IP_HEADER=proxy_protocol\n...\n</code></pre> <p>You will need to add the settings to the environment variables of the BunkerWeb containers (doing it using the ingress is not supported because you will get into trouble when using things like Let's Encrypt) :</p> <pre><code>apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\nname: bunkerweb\nspec:\n...\nspec:\ncontainers:\n- name: bunkerweb\n...\nenv:\n- name: USE_REAL_IP\nvalue: \"yes\"\n- name: USE_PROXY_PROTOCOL\nvalue: \"yes\"\n- name: REAL_IP_FROM\nvalue: \"1.2.3.0/24 100.64.0.0/10\"\n- name: REAL_IP_HEADER\nvalue: \"proxy_protocol\"\n...\n</code></pre> <p>You will need to add the settings to the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>...\nUSE_REAL_IP=yes\nUSE_PROXY_PROTOCOL=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=proxy_protocol\n...\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p> <p>You will need to add the settings to your <code>my_variables.env</code> configuration file :</p> <pre><code>...\nUSE_REAL_IP=yes\nUSE_PROXY_PROTOCOL=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=proxy_protocol\n...\n</code></pre> <p>In your Ansible inventory, you can use the <code>variables_env</code> variable to set the path of configuration file :</p> <pre><code>[mybunkers]\n192.168.0.42 variables_env=\"{{ playbook_dir }}/my_variables.env\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- variables_env: \"{{ playbook_dir }}/my_variables.env\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>Run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>You will need to add the settings to the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>...\nUSE_REAL_IP=yes\nUSE_PROXY_PROTOCOL=yes\nREAL_IP_FROM=1.2.3.0/24 100.64.0.0/16\nREAL_IP_HEADER=proxy_protocol\n...\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p>"},{"location":"quickstart-guide/#protect-udptcp-applications","title":"Protect UDP/TCP applications","text":"<p>Feature is in beta<p>This feature is not production-ready. Feel free to test it and report us any bug using issues in the GitHub repository.</p> </p> <p>BunkerWeb offers the capability to function as a generic UDP/TCP reverse proxy, allowing you to protect any network-based applications operating at least on layer 4 of the OSI model. Instead of utilizing the \"classical\" HTTP module, BunkerWeb leverages the stream module of NGINX.</p> <p>It's important to note that not all settings and security features are available when using the stream module. Additional information on this can be found in the security tuning and settings sections of the documentation.</p> <p>Configuring a basic reverse proxy is quite similar to the HTTP setup, as it involves using the same settings: <code>USE_REVERSE_PROXY=yes</code> and <code>REVERSE_PROXY_HOST=myapp:4242</code>. Even when BunkerWeb is positioned behind a Load Balancer, the settings remain the same (with PROXY protocol being the supported option due to evident reasons).</p> <p>On top of that, the following specific settings are used :</p> <ul> <li><code>SERVER_TYPE=stream</code> : activate <code>stream</code> mode (generic UDP/TCP) instead of <code>http</code> one (which is the default)</li> <li><code>LISTEN_STREAM_PORT=4242</code> : the listening \"plain\" (without SSL/TLS) port that BunkerWeb will listen on</li> <li><code>LISTEN_STREAM_PORT_SSL=4343</code> : the listening \"ssl/tls\" port that BunkerWeb will listen on</li> <li><code>USE_UDP=no</code> : listen for and forward UDP packets instead of TCP</li> </ul> <p>For complete list of settings regarding <code>stream</code> mode, please refer to the settings section of the documentation.</p> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When using Docker integration, the easiest way of protecting existing network applications is to add the services in the <code>bw-services</code> network :</p> <pre><code>version: \"3.5\"\n\nservices:\n\nmyapp1:\nimage: istio/tcp-echo-server:1.2\ncommand: [ \"9000\", \"app1\" ]\nnetworks:\n- bw-services\n\nmyapp2:\nimage: istio/tcp-echo-server:1.2\ncommand: [ \"9000\", \"app2\" ]\nnetworks:\n- bw-services\n\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080 # Keep it if you want to use Let's Encrypt automation\n- 10000:10000 # app1\n- 20000:20000 # app2\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- SERVER_NAME=app1.example.com app2.example.com\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\n- MULTISITE=yes\n- USE_REVERSE_PROXY=yes # Will be applied to all services\n- SERVER_TYPE=stream # Will be applied to all services\n- app1.example.com_REVERSE_PROXY_HOST=myapp1:9000\n- app1.example.com_LISTEN_STREAM_PORT=10000\n- app2.example.com_REVERSE_PROXY_HOST=myapp2:9000\n- app2.example.com_LISTEN_STREAM_PORT=20000\nnetworks:\n- bw-universe\n- bw-services\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nvolumes:\n- bw-data:/data\nenvironment:\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>Before running the Docker autoconf integration stack on your machine, you will need to edit the ports :</p> <pre><code>version: \"3.5\"\n\nservices:\n\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080 # Keep it if you want to use Let's Encrypt automation\n- 10000:10000 # app1\n- 20000:20000 # app2\n\n...\n</code></pre> <p>Once the stack is running, you can connect your existing applications to the <code>bw-services</code> network and configure BunkerWeb with labels :</p> <pre><code>version: '3.5'\n\nservices:\nmyapp1:\nimage: istio/tcp-echo-server:1.2\ncommand: [ \"9000\", \"app1\" ]\nnetworks:\nbw-services:\naliases:\n- myapp1\nlabels:\n- \"bunkerweb.SERVER_NAME=app1.example.com\"\n- \"bunkerweb.SERVER_KIND=stream\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_HOST=myapp1:9000\"\n- \"bunkerweb.LISTEN_STREAM_PORT=10000\"\n\nmyapp2:\nimage: istio/tcp-echo-server:1.2\ncommand: [ \"9000\", \"app2\" ]\nnetworks:\nbw-services:\naliases:\n- myapp2\nlabels:\n- \"bunkerweb.SERVER_NAME=app2.example.com\"\n- \"bunkerweb.SERVER_KIND=stream\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_HOST=myapp2:9000\"\n- \"bunkerweb.LISTEN_STREAM_PORT=20000\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>Before running the Swarm integration stack on your machine, you will need to edit the ports :</p> <pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n# Keep it if you want to use Let's Encrypt automation\n- published: 80\ntarget: 8080\nmode: host\nprotocol: tcp\n# app1\n- published: 10000\ntarget: 10000\nmode: host\nprotocol: tcp\n# app2\n- published: 10000\ntarget: 10000\nmode: host\nprotocol: tcp\n...\n</code></pre> <p>Once the stack is running, you can connect your existing applications to the <code>bw-services</code> network and configure BunkerWeb with labels :</p> <pre><code>version: '3.5'\n\nservices:\n\nmyapp1:\nimage: istio/tcp-echo-server:1.2\ncommand: [ \"9000\", \"app1\" ]\nnetworks:\n- bw-services\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app1.example.com\"\n- \"bunkerweb.SERVER_KIND=stream\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_HOST=myapp1:9000\"\n- \"bunkerweb.LISTEN_STREAM_PORT=10000\"\n\nmyapp2:\nimage: istio/tcp-echo-server:1.2\ncommand: [ \"9000\", \"app2\" ]\nnetworks:\n- bw-services\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app2.example.com\"\n- \"bunkerweb.SERVER_KIND=stream\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_HOST=myapp2:9000\"\n- \"bunkerweb.LISTEN_STREAM_PORT=20000\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>Protection TCP/UDP applications using the <code>stream</code> feature is not yet supported when using the Kubernetes integration.</p> <p>You will need to add the settings to the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>...\nSERVER_NAME=app1.example.com app2.example.com\nMULTISITE=yes\nUSE_REVERSE_PROXY=yes\nSERVER_TYPE=stream\napp1.example.com_REVERSE_PROXY_HOST=myapp1.domain.or.ip:9000\napp1.example.com_LISTEN_STREAM_PORT=10000\napp2.example.com_REVERSE_PROXY_HOST=myapp2.domain.or.ip:9000\napp2.example.com_LISTEN_STREAM_PORT=20000\n...\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p> <p>You will need to add the settings to your <code>my_variables.env</code> configuration file :</p> <pre><code>...\nSERVER_NAME=app1.example.com app2.example.com\nMULTISITE=yes\nUSE_REVERSE_PROXY=yes\nSERVER_TYPE=stream\napp1.example.com_REVERSE_PROXY_HOST=myapp1.domain.or.ip:9000\napp1.example.com_LISTEN_STREAM_PORT=10000\napp2.example.com_REVERSE_PROXY_HOST=myapp2.domain.or.ip:9000\napp2.example.com_LISTEN_STREAM_PORT=20000\n...\n</code></pre> <p>In your Ansible inventory, you can use the <code>variables_env</code> variable to set the path of configuration file :</p> <pre><code>[mybunkers]\n192.168.0.42 variables_env=\"{{ playbook_dir }}/my_variables.env\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- variables_env: \"{{ playbook_dir }}/my_variables.env\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>Run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>You will need to add the settings to the <code>/etc/bunkerweb/variables.env</code> file :</p> <pre><code>...\nSERVER_NAME=app1.example.com app2.example.com\nMULTISITE=yes\nUSE_REVERSE_PROXY=yes\nSERVER_TYPE=stream\napp1.example.com_REVERSE_PROXY_HOST=myapp1.domain.or.ip:9000\napp1.example.com_LISTEN_STREAM_PORT=10000\napp2.example.com_REVERSE_PROXY_HOST=myapp2.domain.or.ip:9000\napp2.example.com_LISTEN_STREAM_PORT=20000\n...\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p>"},{"location":"quickstart-guide/#custom-configurations","title":"Custom configurations","text":"<p>To customize and add custom configurations to BunkerWeb, you can take advantage of its NGINX foundation. Custom NGINX configurations can be added in different NGINX contexts, including configurations for the ModSecurity Web Application Firewall (WAF), which is a core component of BunkerWeb. More details about ModSecurity configurations can be found here.</p> <p>Here are the available types of custom configurations:</p> <ul> <li>http: Configurations at the HTTP level of NGINX.</li> <li>server-http: Configurations at the HTTP/Server level of NGINX.</li> <li>default-server-http: Configurations at the Server level of NGINX, specifically for the \"default server\" when the supplied client name doesn't match any server name in <code>SERVER_NAME</code>.</li> <li>modsec-crs: Configurations applied before the OWASP Core Rule Set is loaded.</li> <li>modsec: Configurations applied after the OWASP Core Rule Set is loaded, or used when the Core Rule Set is not loaded.</li> <li>stream: Configurations at the Stream level of NGINX.</li> <li>server-stream: Configurations at the Stream/Server level of NGINX.</li> </ul> <p>Custom configurations can be applied globally or specifically for a particular server, depending on the applicable context and whether the multisite mode is enabled.</p> <p>The method for applying custom configurations depends on the integration being used. However, the underlying process involves adding files with the <code>.conf</code> suffix to specific folders. To apply a custom configuration for a specific server, the file should be placed in a subfolder named after the primary server name.</p> <p>Some integrations provide more convenient ways to apply configurations, such as using Configs in Docker Swarm or ConfigMap in Kubernetes. These options offer simpler approaches for managing and applying configurations.</p> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When using the Docker integration, you have two choices for the addition of custom configurations :</p> <ul> <li>Using specific settings <code>*_CUSTOM_CONF_*</code> as environment variables (recommended)</li> <li>Writing .conf files to the volume mounted on /data of the scheduler</li> </ul> <p>Using settings</p> <p>The settings to use must follow the pattern <code>&lt;SITE&gt;_CUSTOM_CONF_&lt;TYPE&gt;_&lt;NAME&gt;</code> :</p> <ul> <li><code>&lt;SITE&gt;</code> : optional primary server name if multisite mode is enabled and the config must be applied to a specific service</li> <li><code>&lt;TYPE&gt;</code> : the type of config, accepted values are <code>HTTP</code>, <code>DEFAULT_SERVER_HTTP</code>, <code>SERVER_HTTP</code>, <code>MODSEC</code>, <code>MODSEC_CRS</code>, <code>STREAM</code> and <code>SERVER_STREAM</code></li> <li><code>&lt;NAME&gt;</code> : the name of config without the .conf suffix</li> </ul> <p>Here is a dummy example using a docker-compose file :</p> <pre><code>...\nmybunker:\nimage: bunkerity/bunkerweb:1.5.1\nenvironment:\n- |\nCUSTOM_CONF_SERVER_HTTP_hello-world=\nlocation /hello {\ndefault_type 'text/plain';\ncontent_by_lua_block {\nngx.say('world')\n}\n}\n...\n</code></pre> <p>Using files</p> <p>The first thing to do is to create the folders :</p> <pre><code>mkdir -p ./bw-data/configs/server-http\n</code></pre> <p>You can now write your configurations :</p> <pre><code>echo \"location /hello {\n    default_type 'text/plain';\n    content_by_lua_block {\n        ngx.say('world')\n    }\n}\" &gt; ./bw-data/configs/server-http/hello-world.conf\n</code></pre> <p>Because the scheduler runs as an unprivileged user with UID and GID 101, you will need to edit the permissions :</p> <pre><code>chown -R root:101 bw-data &amp;&amp; \\\nchmod -R 770 bw-data\n</code></pre> <p>When starting the scheduler container, you will need to mount the folder on /data :</p> <pre><code>mybunker:\nimage: bunkerity/bunkerweb:1.5.1\nvolumes:\n- ./bw-data:/data\n...\n</code></pre> <p>When using the Docker autoconf integration, you have two choices for adding custom configurations :</p> <ul> <li>Using specific settings <code>*_CUSTOM_CONF_*</code> as labels (easiest)</li> <li>Writing .conf files to the volume mounted on /data of the scheduler</li> </ul> <p>Using labels</p> <p>Limitations using labels</p> <p>When using labels with the Docker autoconf integration, you can only apply custom configurations for the corresponding web service. Applying http, default-server-http, stream or any global configurations (like server-http or server-stream for all services) is not possible : you will need to mount files for that purpose.</p> <p>The labels to use must follow the pattern <code>bunkerweb.CUSTOM_CONF_&lt;TYPE&gt;_&lt;NAME&gt;</code> :</p> <ul> <li><code>&lt;TYPE&gt;</code> : the type of config, accepted values are <code>SERVER_HTTP</code>, <code>MODSEC</code>, <code>MODSEC_CRS</code> and <code>SERVER_STREAM</code></li> <li><code>&lt;NAME&gt;</code> : the name of config without the .conf suffix </li> </ul> <p>Here is a dummy example using a docker-compose file :</p> <pre><code>myapp:\nimage: tutum/hello-world\nlabels:\n- |\nbunkerweb.CUSTOM_CONF_SERVER_HTTP_hello-world=\nlocation /hello {\ndefault_type 'text/plain';\ncontent_by_lua_block {\nngx.say('world')\n}\n...\n</code></pre> <p>Using files</p> <p>The first thing to do is to create the folders :</p> <pre><code>mkdir -p ./bw-data/configs/server-http\n</code></pre> <p>You can now write your configurations :</p> <pre><code>echo \"location /hello {\n    default_type 'text/plain';\n    content_by_lua_block {\n        ngx.say('world')\n    }\n}\" &gt; ./bw-data/configs/server-http/hello-world.conf\n</code></pre> <p>Because the scheduler runs as an unprivileged user with UID and GID 101, you will need to edit the permissions :</p> <pre><code>chown -R root:101 bw-data &amp;&amp; \\\nchmod -R 770 bw-data\n</code></pre> <p>When starting the scheduler container, you will need to mount the folder on /data :</p> <pre><code>myautoconf:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nvolumes:\n- ./bw-data:/data\n...\n</code></pre> <p>When using the Swarm integration, custom configurations are managed using Docker Configs.</p> <p>To keep it simple, you don't even need to attach the Config to a service : the autoconf service is listening for Config events and will update the custom configurations when needed.</p> <p>When creating a Config, you will need to add special labels :</p> <ul> <li>bunkerweb.CONFIG_TYPE : must be set to a valid custom configuration type (http, server-http, default-server-http, modsec, modsec-crs, stream or server-stream)</li> <li>bunkerweb.CONFIG_SITE : set to a server name to apply configuration to that specific server (optional, will be applied globally if unset)</li> </ul> <p>Here is the example :</p> <pre><code>echo \"location /hello {\n    default_type 'text/plain';\n    content_by_lua_block {\n        ngx.say('world')\n    }\n}\" | docker config create -l bunkerweb.CONFIG_TYPE=server-http my-config -\n</code></pre> <p>There is no update mechanism : the alternative is to remove an existing config using <code>docker config rm</code> and then recreate it.</p> <p>When using the Kubernetes integration, custom configurations are managed using ConfigMap.</p> <p>To keep it simple, you don't even need to use the ConfigMap with a Pod (e.g. as environment variable or volume) : the autoconf Pod is listening for ConfigMap events and will update the custom configurations when needed.</p> <p>When creating a ConfigMap, you will need to add special labels :</p> <ul> <li>bunkerweb.io/CONFIG_TYPE : must be set to a valid custom configuration type (http, server-http, default-server-http, modsec, modsec-crs, stream or server-stream)</li> <li>bunkerweb.io/CONFIG_SITE : set to a server name to apply configuration to that specific server (optional, will be applied globally if unset)</li> </ul> <p>Here is the example :</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: cfg-bunkerweb-all-server-http\nannotations:\nbunkerweb.io/CONFIG_TYPE: \"server-http\"\ndata:\nmyconf: |\nlocation /hello {\ndefault_type 'text/plain';\ncontent_by_lua_block {\nngx.say('world')\n}\n}\n</code></pre> <p>When using the Linux integration, custom configurations must be written to the /etc/bunkerweb/configs folder.</p> <p>Here is an example for server-http/hello-world.conf :</p> <pre><code>location /hello {\n  default_type 'text/plain';\n  content_by_lua_block {\n    ngx.say('world')\n  }\n}\n</code></pre> <p>Because BunkerWeb runs as an unprivileged user (nginx:nginx), you will need to edit the permissions :</p> <pre><code>chown -R root:nginx /etc/bunkerweb/configs &amp;&amp; \\\nchmod -R 770 /etc/bunkerweb/configs\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p> <p>The <code>custom_configs_path[]</code> variable is a dictionary with configuration types (<code>http</code>, <code>server-http</code>, <code>modsec</code>, <code>modsec-crs</code>, <code>stream</code> and <code>server-stream</code>) as keys and the corresponding values are path containing the configuration files.</p> <p>Here is an example for server-http/hello-world.conf :</p> <pre><code>location /hello {\n  default_type 'text/plain';\n  content_by_lua_block {\n    ngx.say('world')\n  }\n}\n</code></pre> <p>And the corresponding <code>custom_configs_path[server-http]</code> variable used in your inventory :</p> <pre><code>  [mybunkers]\n192.168.0.42 custom_configs_path={\"server-http\": \"{{ playbook_dir }}/server-http\"}\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- custom_configs_path: {\n        server-http: \"{{ playbook_dir }}/server-http\"\n}\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>Run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>When using the Vagrant integration, custom configurations must be written to the <code>/etc/bunkerweb/configs</code> folder.</p> <p>Here is an example for server-http/hello-world.conf :</p> <pre><code>location /hello {\n  default_type 'text/plain';\n  content_by_lua_block {\n    ngx.say('world')\n  }\n}\n</code></pre> <p>Because BunkerWeb runs as an unprivileged user (nginx:nginx), you will need to edit the permissions :</p> <pre><code>chown -R root:nginx /etc/bunkerweb/configs &amp;&amp; \\\nchmod -R 770 /etc/bunkerweb/configs\n</code></pre> <p>Don't forget to restart the BunkerWeb service once it's done.</p>"},{"location":"quickstart-guide/#php","title":"PHP","text":"<p>Support is in beta</p> <p>At the moment, PHP support with BunkerWeb is still in beta and we recommend you use a reverse-proxy architecture if you can. By the way, PHP is not supported at all for some integrations like Kubernetes.</p> <p>Testing</p> <p>To perform quick tests when multisite mode is enabled (and if you don't have the proper DNS entries set up for the domains) you can use curl with the HTTP Host header of your choice : <pre><code>curl -H \"Host: app1.example.com\" http://ip-or-fqdn-of-server\n</code></pre></p> <p>If you are using HTTPS, you will need to play with SNI : <pre><code>curl -H \"Host: app1.example.com\" --resolve example.com:443:ip-of-server https://example.com\n</code></pre></p> <p>BunkerWeb supports PHP using external or remote PHP-FPM instances. We will assume that you are already familiar with managing that kind of services.</p> <p>The following settings can be used :</p> <ul> <li><code>REMOTE_PHP</code> : Hostname of the remote PHP-FPM instance.</li> <li><code>REMOTE_PHP_PATH</code> : Root folder containing files in the remote PHP-FPM instance.</li> <li><code>LOCAL_PHP</code> : Path to the local socket file of PHP-FPM instance.</li> <li><code>LOCAL_PHP_PATH</code> : Root folder containing files in the local PHP-FPM instance.</li> </ul> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>When using the Docker integration, to support PHP applications, you will need to :</p> <ul> <li>Mount your PHP files into the <code>/var/www/html</code> folder of BunkerWeb</li> <li>Set up a PHP-FPM container for your application and mount the folder containing PHP files</li> <li>Use the specific settings <code>REMOTE_PHP</code> and <code>REMOTE_PHP_PATH</code> as environment variables when starting BunkerWeb</li> </ul> <p>If you enable the multisite mode, you will need to create separate directories for each of your applications. Each subdirectory should be named using the first value of <code>SERVER_NAME</code>. Here is a dummy example :</p> <pre><code>www\n\u251c\u2500\u2500 app1.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 app2.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u2514\u2500\u2500 app3.example.com\n    \u2514\u2500\u2500 index.php\n\n3 directories, 3 files\n</code></pre> <p>We will assume that your PHP apps are located into a folder named <code>www</code>. Please note that you will need to fix the permissions so BunkerWeb (UID/GID 101) can at least read files and list folders and PHP-FPM (UID/GID 33 if you use the <code>php:fpm</code> image) is the owner of the files and folders :</p> <pre><code>chown -R 33:101 ./www &amp;&amp; \\\nfind ./www -type f -exec chmod 0640 {} \\; &amp;&amp; \\\nfind ./www -type d -exec chmod 0750 {} \\;\n</code></pre> <p>You can now run BunkerWeb, configure it for your PHP application and also run the PHP apps :</p> <pre><code>version: \"3.5\"\n\nservices:\n\nmyapp1:\nimage: php:fpm\nvolumes:\n- ./www/app1.example.com:/app\nnetworks:\n- bw-services\n\nmyapp2:\nimage: php:fpm\nvolumes:\n- ./www/app2.example.com:/app\nnetworks:\n- bw-services\n\nmyapp3:\nimage: php:fpm\nvolumes:\n- ./www/app3.example.com:/app\nnetworks:\n- bw-services\n\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nvolumes:\n- ./www:/var/www/html\nports:\n- 80:8080\n- 443:8443\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- SERVER_NAME=app1.example.com app2.example.com\n- MULTISITE=yes\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\n- app1.example.com_REMOTE_PHP=myapp1\n- app1.example.com_REMOTE_PHP_PATH=/app\n- app2.example.com_REMOTE_PHP=myapp2\n- app2.example.com_REMOTE_PHP_PATH=/app\n- app3.example.com_REMOTE_PHP=myapp3\n- app3.example.com_REMOTE_PHP_PATH=/app\nnetworks:\n- bw-universe\n- bw-services\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nvolumes:\n- bw-data:/data\nenvironment:\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>Multisite mode enabled</p> <p>The Docker autoconf integration integration implies the use of multisite mode : protecting one PHP application is the same as protecting multiple ones.</p> <p>When using the Docker autoconf integration, to support PHP applications, you will need to :</p> <ul> <li>Mount your PHP files into the <code>/var/www/html</code> folder of BunkerWeb</li> <li>Set up a PHP-FPM containers for your applications and mount the folder containing PHP apps</li> <li>Use the specific settings <code>REMOTE_PHP</code> and <code>REMOTE_PHP_PATH</code> as labels for your PHP-FPM container</li> </ul> <p>Since the Docker autoconf implies using the multisite mode, you will need to create separate directories for each of your applications. Each subdirectory should be named using the first value of <code>SERVER_NAME</code>. Here is a dummy example :</p> <pre><code>www\n\u251c\u2500\u2500 app1.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 app2.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u2514\u2500\u2500 app3.example.com\n    \u2514\u2500\u2500 index.php\n\n3 directories, 3 files\n</code></pre> <p>Once the folders are created, copy your files and fix the permissions so BunkerWeb (UID/GID 101) can at least read files and list folders and PHP-FPM (UID/GID 33 if you use the <code>php:fpm</code> image) is the owner of the files and folders :</p> <pre><code>chown -R 33:101 ./www &amp;&amp; \\\nfind ./www -type f -exec chmod 0640 {} \\; &amp;&amp; \\\nfind ./www -type d -exec chmod 0750 {} \\;\n</code></pre> <p>When you start the BunkerWeb autoconf stack, mount the <code>www</code> folder into <code>/var/www/html</code> for the BunkerWeb container :</p> <pre><code>version: '3.5'\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nvolumes:\n- ./www:/var/www/html\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- MULTISITE=yes\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\nnetworks:\n- bw-universe\n- bw-services\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nbw-db:\nimage: mariadb:10.10\nenvironment:\n- MYSQL_RANDOM_ROOT_PASSWORD=yes\n- MYSQL_DATABASE=db\n- MYSQL_USER=bunkerweb\n- MYSQL_PASSWORD=changeme # Remember to set a stronger password for the database\nvolumes:\n- bw-data:/var/lib/mysql\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>You can now create your PHP-FPM containers, mount the correct subfolders and use labels to configure BunkerWeb :</p> <pre><code>version: '3.5'\nservices:\nmyapp1:\nimage: php:fpm\nvolumes:\n- ./www/app1.example.com:/app\nnetworks:\nbw-services:\naliases:\n- myapp1\nlabels:\n- \"bunkerweb.SERVER_NAME=app1.example.com\"\n- \"bunkerweb.REMOTE_PHP=myapp1\"\n- \"bunkerweb.REMOTE_PHP_PATH=/app\"\n\nmyapp2:\nimage: php:fpm\nvolumes:\n- ./www/app2.example.com:/app\nnetworks:\nbw-services:\naliases:\n- myapp2\nlabels:\n- \"bunkerweb.SERVER_NAME=app2.example.com\"\n- \"bunkerweb.REMOTE_PHP=myapp2\"\n- \"bunkerweb.REMOTE_PHP_PATH=/app\"\n\nmyapp3:\nimage: php:fpm\nvolumes:\n- ./www/app3.example.com:/app\nnetworks:\nbw-services:\naliases:\n- myapp3\nlabels:\n- \"bunkerweb.SERVER_NAME=app3.example.com\"\n- \"bunkerweb.REMOTE_PHP=myapp3\"\n- \"bunkerweb.REMOTE_PHP_PATH=/app\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>Multisite mode enabled</p> <p>The Swarm integration integration implies the use of multisite mode : protecting one PHP application is the same as protecting multiple ones.</p> <p>Shared volume</p> <p>Using PHP with the Docker Swarm integration needs a shared volume between all BunkerWeb and PHP-FPM instances which is not covered in this documentation.</p> <p>When using the Docker autoconf integration, to support PHP applications, you will need to :</p> <ul> <li>Mount your PHP files into the <code>/var/www/html</code> folder of BunkerWeb</li> <li>Set up a PHP-FPM containers for your applications and mount the folder containing PHP apps</li> <li>Use the specific settings <code>REMOTE_PHP</code> and <code>REMOTE_PHP_PATH</code> as labels for your PHP-FPM container</li> </ul> <p>Since the Swarm integration implies using the multisite mode, you will need to create separate directories for each of your applications. Each subdirectory should be named using the first value of <code>SERVER_NAME</code>. Here is a dummy example :</p> <pre><code>www\n\u251c\u2500\u2500 app1.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 app2.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u2514\u2500\u2500 app3.example.com\n    \u2514\u2500\u2500 index.php\n\n3 directories, 3 files\n</code></pre> <p>As an example, we will consider that you have a shared folder mounted on your worker nodes on the <code>/shared</code> endpoint.</p> <p>Once the folders are created, copy your files and fix the permissions so BunkerWeb (UID/GID 101) can at least read files and list folders and PHP-FPM (UID/GID 33 if you use the <code>php:fpm</code> image) is the owner of the files and folders :</p> <pre><code>chown -R 33:101 /shared/www &amp;&amp; \\\nfind /shared/www -type f -exec chmod 0640 {} \\; &amp;&amp; \\\nfind /shared/www -type d -exec chmod 0750 {} \\;\n</code></pre> <p>When you start the BunkerWeb stack, mount the <code>/shared/www</code> folder into <code>/var/www/html</code> for the BunkerWeb container :</p> <pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nvolumes:\n- /shared/www:/var/www/html\n...\n</code></pre> <p>You can now create your PHP-FPM services, mount the correct subfolders and use labels to configure BunkerWeb :</p> <pre><code>version: '3.5'\nservices:\nmyapp1:\nimage: php:fpm\nvolumes:\n- ./www/app1.example.com:/app\nnetworks:\nbw-services:\naliases:\n- myapp1\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app1.example.com\"\n- \"bunkerweb.REMOTE_PHP=myapp1\"\n- \"bunkerweb.REMOTE_PHP_PATH=/app\"\n\nmyapp2:\nimage: php:fpm\nvolumes:\n- ./www/app2.example.com:/app\nnetworks:\nbw-services:\naliases:\n- myapp2\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app2.example.com\"\n- \"bunkerweb.REMOTE_PHP=myapp2\"\n- \"bunkerweb.REMOTE_PHP_PATH=/app\"\n\nmyapp3:\nimage: php:fpm\nvolumes:\n- ./www/app3.example.com:/app\nnetworks:\nbw-services:\naliases:\n- myapp3\ndeploy:\nplacement:\nconstraints:\n- \"node.role==worker\"\nlabels:\n- \"bunkerweb.SERVER_NAME=app3.example.com\"\n- \"bunkerweb.REMOTE_PHP=myapp3\"\n- \"bunkerweb.REMOTE_PHP_PATH=/app\"\n\nnetworks:\nbw-services:\nexternal: true\nname: bw-services\n</code></pre> <p>PHP is not supported for Kubernetes</p> <p>Kubernetes integration allows configuration through Ingress and the BunkerWeb controller only supports HTTP applications at the moment.</p> <p>We will assume that you already have the Linux integration stack running on your machine.</p> <p>By default, BunkerWeb will search for web files inside the <code>/var/www/html</code> folder. You can use it to store your PHP applications. Please note that you will need to configure your PHP-FPM service to get or set the user/group of the running processes and the UNIX socket file used to communicate with BunkerWeb.</p> <p>First of all, you will need to make sure that your PHP-FPM instance can access the files inside the <code>/var/www/html</code> folder and also that BunkerWeb can access the UNIX socket file in order to communicate with PHP-FPM. We recommend to set a different user like <code>www-data</code> for the PHP-FPM service and to give the nginx group access to the UNIX socket file. Here is corresponding PHP-FPM configuration :</p> <pre><code>...\n[www]\nuser = www-data\ngroup = www-data\nlisten = /run/php/php-fpm.sock\nlisten.owner = www-data\nlisten.group = nginx\nlisten.mode = 0660\n...\n</code></pre> <p>Don't forget to restart your PHP-FPM service :</p> <pre><code>systemctl restart php-fpm\n</code></pre> <p>If you enable the multisite mode, you will need to create separate directories for each of your applications. Each subdirectory should be named using the first value of <code>SERVER_NAME</code>. Here is a dummy example :</p> <pre><code>/var/www/html\n\u251c\u2500\u2500 app1.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 app2.example.com\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u2514\u2500\u2500 app3.example.com\n    \u2514\u2500\u2500 index.php\n\n3 directories, 3 files\n</code></pre> <p>Please note that you will need to fix the permissions so BunkerWeb (group <code>nginx</code>) can at least read files and list folders and PHP-FPM (user <code>www-data</code> but it might be different depending on your system) is the owner of the files and folders :</p> <pre><code>chown -R www-data:nginx /var/www/html &amp;&amp; \\\nfind /var/www/html -type f -exec chmod 0640 {} \\; &amp;&amp; \\\nfind /var/www/html -type d -exec chmod 0750 {} \\;\n</code></pre> <p>You can now edit the <code>/etc/bunkerweb/variable.env</code> file :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nMULTISITE=yes\nSERVER_NAME=app1.example.com app2.example.com app3.example.com\napp1.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp1.example.com_LOCAL_PHP_PATH=/var/www/html/app1.example.com\napp2.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp2.example.com_LOCAL_PHP_PATH=/var/www/html/app2.example.com\napp3.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp3.example.com_LOCAL_PHP_PATH=/var/www/html/app3.example.com\n</code></pre> <p>Let's check the status of BunkerWeb :</p> <pre><code>systemctl status bunkerweb\n</code></pre> <p>If it's already running we can restart it :</p> <pre><code>systemctl restart bunkerweb\n</code></pre> <p>Otherwise, we will need to start it :</p> <pre><code>systemctl start bunkerweb\n</code></pre> <p>Linux</p> <p>Please follow the instruction for Linux integration to create a local <code>www</code> folder (permissions are not needed, Ansible will do it for you).</p> <p>We will assume that you already have the Ansible integration setup on your machine.</p> <p>Content of the <code>my_variables.env</code> configuration file :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nMULTISITE=yes\nSERVER_NAME=app1.example.com app2.example.com app3.example.com\napp1.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp1.example.com_LOCAL_PHP_PATH=/var/www/html/app1.example.com\napp2.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp2.example.com_LOCAL_PHP_PATH=/var/www/html/app2.example.com\napp3.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp3.example.com_LOCAL_PHP_PATH=/var/www/html/app3.example.com\n</code></pre> <p>The <code>custom_site</code> variable can be used to specify a directory containing your application files (e.g : <code>www</code>) that will be copied to <code>/var/www/html</code> and the <code>custom_www_owner</code> variable contains the owner that should be set for the files and folders. Here is an example using the Ansible inventory (replace <code>www-data</code> with the user running the PHP-FPM service):</p> <pre><code>[mybunkers]\n192.168.0.42 variables_env=\"{{ playbook_dir }}/my_variables.env\" custom_www=\"{{ playbook_dir }}/my_app\" custom_www_owner=\"www-data\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- variables_env: \"{{ playbook_dir }}/my_variables.env\"\n- custom_www: \"{{ playbook_dir }}/www\"\n- custom_www_owner: \"www-data\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>You can now run the playbook :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>Linux</p> <p>Please follow the instruction for Linux integration to create the <code>/var/www/html</code> folder.</p> <p>We will assume that you already have the Vagrant integration stack running on your machine.</p> <p>Once PHP files are copied into the <code>/var/www/html</code>folder, you can now edit the <code>/etc/bunkerweb/variable.env</code> file :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nMULTISITE=yes\nSERVER_NAME=app1.example.com app2.example.com app3.example.com\napp1.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp1.example.com_LOCAL_PHP_PATH=/var/www/html/app1.example.com\napp2.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp2.example.com_LOCAL_PHP_PATH=/var/www/html/app2.example.com\napp3.example.com_LOCAL_PHP=/run/php/php-fpm.sock\napp3.example.com_LOCAL_PHP_PATH=/var/www/html/app3.example.com\n</code></pre> <p>Let's check the status of BunkerWeb :</p> <pre><code>systemctl status bunkerweb\n</code></pre> <p>If it's already running we can restart it :</p> <pre><code>systemctl restart bunkerweb\n</code></pre> <p>Otherwise, we will need to start it :</p> <pre><code>systemctl start bunkerweb\n</code></pre>"},{"location":"quickstart-guide/#ipv6","title":"IPv6","text":"<p>Feature is in beta<p>This feature is not production-ready. Feel free to test it and report us any bug using issues in the GitHub repository.</p> </p> <p>By default, BunkerWeb will only listen on IPv4 adresses and won't use IPv6 for network communications. If you want to enable IPv6 support, you need to set <code>USE_IPV6=yes</code>. Please note that IPv6 configuration of your network and environment is out-of-the-scope of this documentation.</p> DockerDocker autoconf <p>First of all, you will need to configure your Docker daemon to enable IPv6 support for containers and use ip6tables if needed. Here is sample configuration for your <code>/etc/docker/daemon.json</code> file :</p> <pre><code>{\n\"experimental\": true,\n\"ipv6\": true,\n\"ip6tables\": true,\n\"fixed-cidr-v6\": \"fd00:dead:beef::/48\"\n}\n</code></pre> <p>You can now restart the Docker service to apply the changes :</p> <pre><code>systemctl restart docker\n</code></pre> <p>Once Docker is setup to support IPv6 you can add the <code>USE_IPV6</code> setting and configure the <code>bw-services</code> for IPv6 :</p> <pre><code>version: '3.5'\n\nservices:\n\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nenvironment:\n- USE_IPv6=yes\n\n...\n\nnetworks:\nbw-services:\nname: bw-services\nenable_ipv6: true\nipam:\nconfig:\n- subnet: fd00:13:37::/48\ngateway: fd00:13:37::1\n\n...\n</code></pre> <p>First of all, you will need to configure your Docker daemon to enable IPv6 support for containers and use ip6tables if needed. Here is sample configuration for your <code>/etc/docker/daemon.json</code> file :</p> <pre><code>{\n\"experimental\": true,\n\"ipv6\": true,\n\"ip6tables\": true,\n\"fixed-cidr-v6\": \"fd00:dead:beef::/48\"\n}\n</code></pre> <p>You can now restart the Docker service to apply the changes :</p> <pre><code>systemctl restart docker\n</code></pre> <p>Once Docker is setup to support IPv6 you can add the <code>USE_IPV6</code> setting and configure the IPv6 for the <code>bw-services</code> network :</p> <pre><code>version: '3.5'\n\nservices:\n\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nenvironment:\n- USE_IPv6=yes\n\n...\n\nnetworks:\nbw-services:\nname: bw-services\nenable_ipv6: true\nipam:\nconfig:\n- subnet: fd00:13:37::/48\ngateway: fd00:13:37::1\n\n...\n</code></pre>"},{"location":"security-tuning/","title":"Security tuning","text":"<p>BunkerWeb offers many security features that you can configure with settings. Even if the default values of settings ensure a minimal \"security by default\", we strongly recommend you tune them. By doing so you will be able to ensure the security level of your choice but also manage false positives.</p> <p>Other settings</p> <p>This section only focuses on security tuning, see the settings section of the documentation for other settings.</p> <p> </p> Overview and order of the core security plugins"},{"location":"security-tuning/#http-protocol","title":"HTTP protocol","text":""},{"location":"security-tuning/#deny-status-code","title":"Deny status code","text":"<p>STREAM support </p> <p>The first thing to define is the kind of action to do when a client access is denied. You can control the action with the <code>DENY_HTTP_STATUS</code> setting which allows the following values :</p> <ul> <li><code>403</code> : send a \"classical\" Forbidden HTTP status code (a web page or custom content will be displayed)</li> <li><code>444</code> : close the connection (no web page or custom content will be displayed)</li> </ul> <p>The default value is <code>403</code> and we suggest you set it to <code>444</code> only if you already fixed a lot of false positive, you are familiar with BunkerWeb and want a higher level of security.</p> <p>When using stream mode, value is ignored and always set to <code>444</code> with effect of closing the connection.</p>"},{"location":"security-tuning/#default-server","title":"Default server","text":"<p>STREAM support </p> <p>In the HTTP protocol, the Host header is used to determine which server the client wants to send the request to. That header is facultative and may be missing from the request or can be set as an unknown value. This is a common case, a lot of bots are scanning the Internet and are trying to exploit services or simply doing some fingerprinting.</p> <p>You can disable any request containing undefined or unknown Host value by setting <code>DISABLE_DEFAULT_SERVER</code> to <code>yes</code> (default : <code>no</code>). Please note that clients won't even receive a response, the TCP connection will be closed (using the special 444 status code of NGINX).</p>"},{"location":"security-tuning/#allowed-methods","title":"Allowed methods","text":"<p>STREAM support </p> <p>You can control the allowed HTTP methods by listing them (separated with \"|\") in the <code>ALLOWED_METHODS</code> setting (default : <code>GET|POST|HEAD</code>). Clients sending a method which is not listed will get a \"405 - Method Not Allowed\".</p>"},{"location":"security-tuning/#max-sizes","title":"Max sizes","text":"<p>STREAM support </p> <p>You can control the maximum body size with the <code>MAX_CLIENT_SIZE</code> setting (default : <code>10m</code>). See here for accepted values. You can use the special value <code>0</code> to allow a body of infinite size (not recommended).</p>"},{"location":"security-tuning/#serve-files","title":"Serve files","text":"<p>STREAM support </p> <p>To disable serving files from the www folder, you can set <code>SERVE_FILES</code> to <code>no</code> (default : <code>yes</code>). The value <code>no</code> is recommended if you use BunkerWeb as a reverse proxy.</p>"},{"location":"security-tuning/#headers","title":"Headers","text":"<p>STREAM support </p> <p>Headers are very important when it comes to HTTP security. While some of them might be too verbose, others' verbosity will need to be increased, especially on the client-side.</p>"},{"location":"security-tuning/#remove-headers","title":"Remove headers","text":"<p>STREAM support </p> <p>You can automatically remove verbose headers in the HTTP responses by using the <code>REMOVE_HEADERS</code> setting (default : <code>Server X-Powered-By X-AspNet-Version X-AspNetMvc-Version</code>).</p>"},{"location":"security-tuning/#keep-upstream-headers","title":"Keep upstream headers","text":"<p>STREAM support </p> <p>You can automatically keep headers from upstream servers and prevent BunkerWeb from overriding them in the HTTP responses by using the <code>KEEP_UPSTREAM_HEADERS</code> setting (default : <code>Content-Security-Policy Permissions-Policy Feature-Policy X-Frame-Options</code>). A special value <code>*</code> is available to keep all headers. List of headers to keep must be separated with a space. Note that if the header is not present in the upstream response, it will be added by BunkerWeb.</p>"},{"location":"security-tuning/#cookies","title":"Cookies","text":"<p>STREAM support </p> <p>When it comes to cookies security, we can use the following flags :</p> <ul> <li>HttpOnly : disable any access to the cookie from Javascript using document.cookie</li> <li>SameSite : policy when requests come from third-party websites</li> <li>Secure : only send cookies on HTTPS request</li> </ul> <p>Cookie flags can be overridden with values of your choice by using the <code>COOKIE_FLAGS</code> setting (default : <code>* HttpOnly SameSite=Lax</code>). See here for accepted values.</p> <p>The Secure flag can be automatically added if HTTPS is used by using the <code>COOKIE_AUTO_SECURE_FLAG</code> setting (default : <code>yes</code>). The value <code>no</code> is not recommended unless you know what you're doing.</p>"},{"location":"security-tuning/#security-headers","title":"Security headers","text":"<p>STREAM support </p> <p>Various security headers are available and most of them can be set using BunkerWeb settings. Here is the list of headers, the corresponding setting and default value :</p> Header Setting Default <code>Content-Security-Policy</code> <code>CONTENT_SECURITY_POLICY</code> <code>object-src 'none'; frame-src 'self'; child-src 'self'; form-action 'self'; frame-ancestors 'self';</code> <code>Strict-Transport-Security</code> <code>STRICT_TRANSPORT_SECURITY</code> <code>max-age=31536000</code> <code>Referrer-Policy</code> <code>REFERRER_POLICY</code> <code>strict-origin-when-cross-origin</code> <code>Permissions-Policy</code> <code>PERMISSIONS_POLICY</code> <code>accelerometer=(), ambient-light-sensor=(), autoplay=(), battery=(), camera=(), cross-origin-isolated=(), display-capture=(), document-domain=(), encrypted-media=(), execution-while-not-rendered=(), execution-while-out-of-viewport=(), fullscreen=(), geolocation=(), gyroscope=(), hid=(), idle-detection=(), magnetometer=(), microphone=(), midi=(), navigation-override=(), payment=(), picture-in-picture=(), publickey-credentials-get=(), screen-wake-lock=(), serial=(), usb=(), web-share=(), xr-spatial-tracking=()</code> <code>Feature-Policy</code> <code>FEATURE_POLICY</code> <code>accelerometer 'none'; ambient-light-sensor 'none'; autoplay 'none'; battery 'none'; camera 'none'; display-capture 'none'; document-domain 'none'; encrypted-media 'none'; execution-while-not-rendered 'none'; execution-while-out-of-viewport 'none'; fullscreen 'none'; 'none'; geolocation 'none'; gyroscope 'none'; layout-animation 'none'; legacy-image-formats 'none'; magnetometer 'none'; microphone 'none'; midi 'none'; navigation-override 'none'; payment 'none'; picture-in-picture 'none'; publickey-credentials-get 'none'; speaker-selection 'none'; sync-xhr 'none'; unoptimized-images 'none'; unsized-media 'none'; usb 'none'; screen-wake-lock 'none'; web-share 'none'; xr-spatial-tracking 'none';</code> <code>X-Frame-Options</code> <code>X_FRAME_OPTIONS</code> <code>SAMEORIGIN</code> <code>X-Content-Type-Options</code> <code>X_CONTENT_TYPE_OPTIONS</code> <code>nosniff</code> <code>X-XSS-Protection</code> <code>X_XSS_PROTECTION</code> <code>1; mode=block</code>"},{"location":"security-tuning/#cors","title":"CORS","text":"<p>STREAM support </p> <p>Cross-Origin Resource Sharing lets you manage how your service can be contacted from different origins. Please note that you will have to allow the <code>OPTIONS</code> HTTP method using the <code>ALLOWED_METHODS</code> if you want to enable it (more info here). Here is the list of settings related to CORS :</p> Setting Default Context Multiple Description <code>USE_CORS</code> <code>no</code> multisite no Use CORS <code>CORS_ALLOW_ORIGIN</code> <code>*</code> multisite no Allowed origins to make CORS requests : PCRE regex or *. <code>CORS_EXPOSE_HEADERS</code> <code>Content-Length,Content-Range</code> multisite no Value of the Access-Control-Expose-Headers header. <code>CORS_MAX_AGE</code> <code>86400</code> multisite no Value of the Access-Control-Max-Age header. <code>CORS_ALLOW_CREDENTIALS</code> <code>no</code> multisite no Send the Access-Control-Allow-Credentials header. <code>CORS_ALLOW_METHODS</code> <code>GET, POST, OPTIONS</code> multisite no Value of the Access-Control-Allow-Methods header. <code>CORS_ALLOW_HEADERS</code> <code>DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range</code> multisite no Value of the Access-Control-Allow-Headers header. <code>CORS_DENY_REQUEST</code> <code>yes</code> multisite no Deny request and don't send it to backend if Origin is not allowed. <p>Here is some examples of possible values for <code>CORS_ALLOW_ORIGIN</code> setting :</p> <ul> <li><code>*</code> will allow all origin</li> <li><code>^https://www\\.example\\.com$</code> will allow <code>https://www.example.com</code></li> <li><code>^https://.+\\.example.com$</code> will allow any origins when domain ends with <code>.example.com</code></li> <li><code>^https://(www\\.example1\\.com|www\\.example2\\.com)$</code> will allow both <code>https://www.example1.com</code> and <code>https://www.example2.com</code></li> <li><code>^https?://www\\.example\\.com$</code> will allow both <code>https://www.example.com</code> and <code>http://www.example.com</code></li> </ul>"},{"location":"security-tuning/#https-ssltls","title":"HTTPS / SSL/TLS","text":"<p>Besides the HTTPS configuration, the following settings related to HTTPS can be set :</p> Setting Default Description <code>REDIRECT_HTTP_TO_HTTPS</code> <code>no</code> When set to <code>yes</code>, will redirect every HTTP request to HTTPS even if BunkerWeb is not configured with HTTPS. <code>AUTO_REDIRECT_HTTP_TO_HTTPS</code> <code>yes</code> When set to <code>yes</code>, will redirect every HTTP request to HTTPS only if BunkerWeb is configured with HTTPS. <code>SSL_PROTOCOLS</code> <code>TLSv1.2 TLSv1.3</code> List of supported SSL/TLS protocols when SSL is enabled. <code>HTTP2</code> <code>yes</code> When set to <code>yes</code>, will enable HTTP2 protocol support when using HTTPS. <code>LISTEN_HTTP</code> <code>yes</code> When set to <code>no</code>, BunkerWeb will not listen for HTTP requests. Useful if you want HTTPS only for example."},{"location":"security-tuning/#lets-encrypt","title":"Let's Encrypt","text":"<p>STREAM support </p> <p>BunkerWeb comes with automatic Let's Encrypt certificate generation and renewal. This is the easiest way of getting HTTPS working out of the box for public-facing web applications. Please note that you will need to set up proper DNS A record(s) for each of your domains pointing to your public IP(s) where BunkerWeb is accessible.</p> <p>Here is the list of related settings :</p> Setting Default Description <code>AUTO_LETS_ENCRYPT</code> <code>no</code> When set to <code>yes</code>, HTTPS will be enabled with automatic certificate generation and renewal from Let's Encrypt. <code>EMAIL_LETS_ENCRYPT</code> <code>contact@{FIRST_SERVER}</code> Email to use when generating certificates. Let's Encrypt will send notifications to that email like certificate expiration. <code>USE_LETS_ENCRYPT_STAGING</code> <code>no</code> When set to <code>yes</code>, the staging server of Let's Encrypt will be used instead of the production one. Useful when doing tests to avoid being \"blocked\" due to limits. <p>Full Let's Encrypt automation is fully working with stream mode as long as you open the <code>80/tcp</code> port from the outside. Please note that you will need to use the <code>LISTEN_STREAM_PORT_SSL</code> setting in order to choose your listening SSL/TLS port.</p>"},{"location":"security-tuning/#custom-certificate","title":"Custom certificate","text":"<p>STREAM support </p> <p>If you want to use your own certificates, here is the list of related settings :</p> Setting Default Context Multiple Description <code>USE_CUSTOM_SSL</code> <code>no</code> multisite no Use custom HTTPS certificate. <code>CUSTOM_SSL_CERT</code> multisite no Full path of the certificate or bundle file (must be readable by the scheduler). <code>CUSTOM_SSL_KEY</code> multisite no Full path of the key file (must be readable by the scheduler). <p>When <code>USE_CUSTOM_SSL</code> is set to <code>yes</code>, BunkerWeb will check every day if the custom certificate specified in <code>CUSTOM_SSL_CERT</code> is modified and will reload NGINX if that's the case.</p> <p>When using stream mode, you will need to use the <code>LISTEN_STREAM_PORT_SSL</code> setting in order to choose your listening SSL/TLS port.</p>"},{"location":"security-tuning/#self-signed","title":"Self-signed","text":"<p>STREAM support </p> <p>If you want to quickly test HTTPS for staging/dev environment you can configure BunkerWeb to generate self-signed certificates, here is the list of related settings :</p> Setting Default Description <code>GENERATE_SELF_SIGNED_SSL</code> <code>no</code> When set to <code>yes</code>, HTTPS will be enabled with automatic self-signed certificate generation and renewal from Let's Encrypt. <code>SELF_SIGNED_SSL_EXPIRY</code> <code>365</code> Number of days for the certificate expiration (-days value used with openssl). <code>SELF_SIGNED_SSL_SUBJ</code> <code>/CN=www.example.com/</code> Certificate subject to use (-subj value used with openssl). <p>When using stream mode, you will need to use the <code>LISTEN_STREAM_PORT_SSL</code> setting in order to choose your listening SSL/TLS port.</p>"},{"location":"security-tuning/#modsecurity","title":"ModSecurity","text":"<p>STREAM support </p> <p>ModSecurity is integrated and enabled by default alongside the OWASP Core Rule Set within BunkerWeb. Here is the list of related settings :</p> Setting Default Description <code>USE_MODSECURITY</code> <code>yes</code> When set to <code>yes</code>, ModSecurity will be enabled. <code>USE_MODSECURITY_CRS</code> <code>yes</code> When set to <code>yes</code> and <code>USE_MODSECURITY</code> is also set to <code>yes</code>, the OWASP Core Rule Set will be loaded. <p>We strongly recommend keeping both ModSecurity and the OWASP Core Rule Set enabled. The only downsides are the false positives that may occur. But they can be fixed with some efforts and the CRS team maintains a list of exclusions for common applications (e.g., WordPress, Nextcloud, Drupal, Cpanel, ...).</p> <p>Tuning ModSecurity and the CRS can be done using custom configurations :</p> <ul> <li>modsec-crs : before the OWASP Core Rule Set is loaded</li> <li>modsec : after the OWASP Core Rule Set is loaded (also used if CRS is not loaded)</li> </ul> <p>For example, you can add a custom configuration with type <code>modsec-crs</code> to add CRS exclusions :</p> <pre><code>SecAction \\\n \"id:900130,\\\n  phase:1,\\\n  nolog,\\\n  pass,\\\n  t:none,\\\n  setvar:tx.crs_exclusions_wordpress=1\"\n</code></pre> <p>You can also add a custom configuration with type <code>modsec</code> to update loaded CRS rules :</p> <pre><code>SecRule REQUEST_FILENAME \"/wp-admin/admin-ajax.php\" \"id:1,ctl:ruleRemoveByTag=attack-xss,ctl:ruleRemoveByTag=attack-rce\"\nSecRule REQUEST_FILENAME \"/wp-admin/options.php\" \"id:2,ctl:ruleRemoveByTag=attack-xss\"\nSecRule REQUEST_FILENAME \"^/wp-json/yoast\" \"id:3,ctl:ruleRemoveById=930120\"\n</code></pre>"},{"location":"security-tuning/#bad-behavior","title":"Bad behavior","text":"<p>STREAM support </p> <p>When attackers search for and/or exploit vulnerabilities they might generate some \"suspicious\" HTTP status codes that a \"regular\" user won\u2019t generate within a period of time. If we detect that kind of behavior we can ban the offending IP address and force the attacker to come up with a new one.</p> <p>That kind of security measure is implemented and enabled by default in BunkerWeb and is called \"Bad behavior\". Here is the list of the related settings :</p> Setting Default Description <code>USE_BAD_BEHAVIOR</code> <code>yes</code> When set to <code>yes</code>, the Bad behavior feature will be enabled. <code>BAD_BEHAVIOR_STATUS_CODES</code> <code>400 401 403 404 405 429 444</code> List of HTTP status codes considered as \"suspicious\". <code>BAD_BEHAVIOR_BAN_TIME</code> <code>86400</code> The duration time (in seconds) of a ban when a client reached the threshold. <code>BAD_BEHAVIOR_THRESHOLD</code> <code>10</code> Maximum number of \"suspicious\" HTTP status codes within the time period. <code>BAD_BEHAVIOR_COUNT_TIME</code> <code>60</code> Period of time during which we count \"suspicious\" HTTP status codes. <p>In other words, with the default values, if a client generates more than <code>10</code> status codes from the list <code>400 401 403 404 405 429 444</code> within <code>60</code> seconds their IP address will be banned for <code>86400</code> seconds.</p> <p>When using stream mode, only the <code>444</code> status code will count as \"bad\".</p>"},{"location":"security-tuning/#antibot","title":"Antibot","text":"<p>STREAM support </p> <p>Attackers will certainly use automated tools to exploit/find some vulnerabilities in your web applications. One countermeasure is to challenge the users to detect if they look like a bot. If the challenge is solved, we consider the client as \"legitimate\" and they can access the web application.</p> <p>That kind of security is implemented but not enabled by default in BunkerWeb and is called \"Antibot\". Here is the list of supported challenges :</p> <ul> <li>Cookie : send a cookie to the client, we expect to get the cookie back on other requests</li> <li>Javascript : force a client to solve a computation challenge using Javascript</li> <li>Captcha : force the client to solve a classical captcha (no external dependencies)</li> <li>hCaptcha : force the client to solve a captcha from hCaptcha</li> <li>reCAPTCHA : force the client to get a minimum score with Google reCAPTCHA</li> <li>Turnstile : enforce rate limiting and access control for APIs and web applications using various mechanisms with Coudflare Turnstile</li> </ul> <p>Here is the list of related settings :</p> Setting Default Context Multiple Description <code>USE_ANTIBOT</code> <code>no</code> multisite no Activate antibot feature. <code>ANTIBOT_URI</code> <code>/challenge</code> multisite no Unused URI that clients will be redirected to to solve the challenge. <code>ANTIBOT_RECAPTCHA_SCORE</code> <code>0.7</code> multisite no Minimum score required for reCAPTCHA challenge. <code>ANTIBOT_RECAPTCHA_SITEKEY</code> multisite no Sitekey for reCAPTCHA challenge. <code>ANTIBOT_RECAPTCHA_SECRET</code> multisite no Secret for reCAPTCHA challenge. <code>ANTIBOT_HCAPTCHA_SITEKEY</code> multisite no Sitekey for hCaptcha challenge. <code>ANTIBOT_HCAPTCHA_SECRET</code> multisite no Secret for hCaptcha challenge. <code>ANTIBOT_TURNSTILE_SITEKEY</code> multisite no Sitekey for Turnstile challenge. <code>ANTIBOT_TURNSTILE_SECRET</code> multisite no Secret for Turnstile challenge. <code>ANTIBOT_TIME_RESOLVE</code> <code>60</code> multisite no Maximum time (in seconds) clients have to resolve the challenge. Once this time has passed, a new challenge will be generated. <code>ANTIBOT_TIME_VALID</code> <code>86400</code> multisite no Maximum validity time of solved challenges. Once this time has passed, clients will need to resolve a new one. <p>Please note that antibot feature is using a cookie to maintain a session with clients. If you are using BunkerWeb in a clustered environment, you will need to set the <code>SESSIONS_SECRET</code> and <code>SESSIONS_NAME</code> settings to another value than the default one (which is <code>random</code>). You will find more info about sessions here.</p>"},{"location":"security-tuning/#blacklisting-whitelisting-and-greylisting","title":"Blacklisting, whitelisting and greylisting","text":"<p>The blacklisting security feature is very easy to understand : if a specific criteria is met, the client will be banned. As for the whitelisting, it's the exact opposite : if a specific criteria is met, the client will be allowed and no additional security check will be done. Whereas for the greylisting :  if a specific criteria is met, the client will be allowed but additional security checks will be done.</p> <p>You can configure blacklisting, whitelisting and greylisting at the same time. If that's the case, note that whitelisting is executed before blacklisting and greylisting : even if a criteria is true for all of them, the client will be whitelisted.</p>"},{"location":"security-tuning/#blacklisting","title":"Blacklisting","text":"<p>STREAM support </p> <p>You can use the following settings to set up blacklisting :</p> Setting Default Context Multiple Description <code>USE_BLACKLIST</code> <code>yes</code> multisite no Activate blacklist feature. <code>BLACKLIST_IP</code> multisite no List of IP/network, separated with spaces, to block. <code>BLACKLIST_IP_URLS</code> <code>https://www.dan.me.uk/torlist/?exit</code> global no List of URLs, separated with spaces, containing bad IP/network to block. <code>BLACKLIST_RDNS_GLOBAL</code> <code>yes</code> multisite no Only perform RDNS blacklist checks on global IP addresses. <code>BLACKLIST_RDNS</code> <code>.shodan.io .censys.io</code> multisite no List of reverse DNS suffixes, separated with spaces, to block. <code>BLACKLIST_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to block. <code>BLACKLIST_ASN</code> multisite no List of ASN numbers, separated with spaces, to block. <code>BLACKLIST_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to block. <code>BLACKLIST_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to block. <code>BLACKLIST_USER_AGENT_URLS</code> <code>https://raw.githubusercontent.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker/master/_generator_lists/bad-user-agents.list</code> global no List of URLs, separated with spaces, containing bad User-Agent to block. <code>BLACKLIST_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to block. <code>BLACKLIST_URI_URLS</code> global no List of URLs, separated with spaces, containing bad URI to block. <code>BLACKLIST_IGNORE_IP</code> multisite no List of IP/network, separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_IP_URLS</code> global no List of URLs, separated with spaces, containing IP/network to ignore in the blacklist. <code>BLACKLIST_IGNORE_RDNS</code> multisite no List of reverse DNS suffixes, separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to ignore in the blacklist. <code>BLACKLIST_IGNORE_ASN</code> multisite no List of ASN numbers, separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to ignore in the blacklist. <code>BLACKLIST_IGNORE_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_USER_AGENT_URLS</code> global no List of URLs, separated with spaces, containing User-Agent to ignore in the blacklist. <code>BLACKLIST_IGNORE_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_URI_URLS</code> global no List of URLs, separated with spaces, containing URI to ignore in the blacklist. <p>When using stream mode, only IP, RDNS and ASN checks will be done.</p>"},{"location":"security-tuning/#greylisting","title":"Greylisting","text":"<p>STREAM support </p> <p>You can use the following settings to set up greylisting :</p> Setting Default Context Multiple Description <code>USE_GREYLIST</code> <code>no</code> multisite no Activate greylist feature. <code>GREYLIST_IP</code> multisite no List of IP/network, separated with spaces, to put into the greylist. <code>GREYLIST_IP_URLS</code> global no List of URLs, separated with spaces, containing good IP/network to put into the greylist. <code>GREYLIST_RDNS_GLOBAL</code> <code>yes</code> multisite no Only perform RDNS greylist checks on global IP addresses. <code>GREYLIST_RDNS</code> multisite no List of reverse DNS suffixes, separated with spaces, to put into the greylist. <code>GREYLIST_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to put into the greylist. <code>GREYLIST_ASN</code> multisite no List of ASN numbers, separated with spaces, to put into the greylist. <code>GREYLIST_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to put into the greylist. <code>GREYLIST_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to put into the greylist. <code>GREYLIST_USER_AGENT_URLS</code> global no List of URLs, separated with spaces, containing good User-Agent to put into the greylist. <code>GREYLIST_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to put into the greylist. <code>GREYLIST_URI_URLS</code> global no List of URLs, separated with spaces, containing bad URI to put into the greylist. <p>When using stream mode, only IP, RDNS and ASN checks will be done.</p>"},{"location":"security-tuning/#whitelisting","title":"Whitelisting","text":"<p>STREAM support </p> <p>You can use the following settings to set up whitelisting :</p> Setting Default Context Multiple Description <code>USE_WHITELIST</code> <code>yes</code> multisite no Activate whitelist feature. <code>WHITELIST_IP</code> <code>20.191.45.212 40.88.21.235 40.76.173.151 40.76.163.7 20.185.79.47 52.142.26.175 20.185.79.15 52.142.24.149 40.76.162.208 40.76.163.23 40.76.162.191 40.76.162.247 54.208.102.37 107.21.1.8</code> multisite no List of IP/network, separated with spaces, to put into the whitelist. <code>WHITELIST_IP_URLS</code> global no List of URLs, separated with spaces, containing good IP/network to whitelist. <code>WHITELIST_RDNS_GLOBAL</code> <code>yes</code> multisite no Only perform RDNS whitelist checks on global IP addresses. <code>WHITELIST_RDNS</code> <code>.google.com .googlebot.com .yandex.ru .yandex.net .yandex.com .search.msn.com .baidu.com .baidu.jp .crawl.yahoo.net .fwd.linkedin.com .twitter.com .twttr.com .discord.com</code> multisite no List of reverse DNS suffixes, separated with spaces, to whitelist. <code>WHITELIST_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to whitelist. <code>WHITELIST_ASN</code> <code>32934</code> multisite no List of ASN numbers, separated with spaces, to whitelist. <code>WHITELIST_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to whitelist. <code>WHITELIST_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to whitelist. <code>WHITELIST_USER_AGENT_URLS</code> global no List of URLs, separated with spaces, containing good User-Agent to whitelist. <code>WHITELIST_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to whitelist. <code>WHITELIST_URI_URLS</code> global no List of URLs, separated with spaces, containing bad URI to whitelist. <p>When using stream mode, only IP, RDNS and ASN checks will be done.</p>"},{"location":"security-tuning/#reverse-scan","title":"Reverse scan","text":"<p>STREAM support </p> <p>Reverse scan is a feature designed to detect open ports by establishing TCP connections with clients' IP addresses. Consider adding this feature if you want to detect possible open proxies or connections from servers.</p> <p>We provide a list of suspicious ports by default but it can be modified to fit your needs. Be mindful, adding too many ports to the list can significantly slow down clients' connections due to the network checks. If a listed port is open, the client's access will be denied.</p> <p>Please be aware, this feature is new and further improvements will be added soon.</p> <p>Here is the list of settings related to reverse scan :</p> Setting Default Description <code>USE_REVERSE_SCAN</code> <code>no</code> When set to <code>yes</code>, will enable ReverseScan. <code>REVERSE_SCAN_PORTS</code> <code>22 80 443 3128 8000 8080</code> List of suspicious ports to scan. <code>REVERSE_SCAN_TIMEOUT</code> <code>500</code> Specify the maximum timeout (in ms) when scanning a port."},{"location":"security-tuning/#bunkernet","title":"BunkerNet","text":"<p>STREAM support </p> <p>BunkerNet is a crowdsourced database of malicious requests shared between all BunkerWeb instances over the world.</p> <p>If you enable BunkerNet, malicious requests will be sent to a remote server and will be analyzed by our systems. By doing so, we can extract malicious data from everyone's reports and give back the results to each BunkerWeb instances participating into BunkerNet.</p> <p>At the moment, that feature should be considered in \"beta\". We only extract malicious IP and we are very strict about how we do it to avoid any \"poisoning\". We strongly recommend activating it (which is the default) because the more instances participate, the more data we have to improve the algorithm.</p> <p>The setting used to enable or disable BunkerNet is <code>USE_BUNKERNET</code> (default : <code>yes</code>).</p>"},{"location":"security-tuning/#dnsbl","title":"DNSBL","text":"<p>STREAM support </p> <p>DNSBL or \"DNS BlackList\" is an external list of malicious IPs that you query using the DNS protocol. Automatic querying of that kind of blacklist is supported by BunkerWeb. If a remote DNSBL server of your choice says that the IP address of the client is in the blacklist, it will be banned.</p> <p>Here is the list of settings related to DNSBL :</p> Setting Default Description <code>USE_DNSBL</code> <code>yes</code> When set to <code>yes</code>, will enable DNSBL checking. <code>DNSBL_LIST</code> <code>bl.blocklist.de problems.dnsbl.sorbs.net sbl.spamhaus.org xbl.spamhaus.org</code> List of DNSBL servers to ask."},{"location":"security-tuning/#limiting","title":"Limiting","text":"<p>BunkerWeb supports applying a limit policy to :</p> <ul> <li>Number of connections per IP</li> <li>Number of requests per IP and URL within a time period</li> </ul> <p>Please note that it should not be considered as an effective solution against DoS or DDoS but rather as an anti-bruteforce measure or rate limit policy for API.</p> <p>In both cases (connections or requests) if the limit is reached, the client will receive the HTTP status \"429 - Too Many Requests\".</p>"},{"location":"security-tuning/#connections","title":"Connections","text":"<p>STREAM support </p> <p>The following settings are related to the Limiting connections feature :</p> Setting Default Description <code>USE_LIMIT_CONN</code> <code>yes</code> When set to <code>yes</code>, will limit the maximum number of concurrent connections for a given IP. <code>LIMIT_CONN_MAX_HTTP1</code> <code>10</code> Maximum number of concurrent connections when using HTTP1 protocol. <code>LIMIT_CONN_MAX_HTTP2</code> <code>100</code> Maximum number of concurrent streams when using HTTP2 protocol. <code>LIMIT_CONN_MAX_STREAM</code> <code>10</code> Maximum number of connections per IP when using stream."},{"location":"security-tuning/#requests","title":"Requests","text":"<p>STREAM support </p> <p>The following settings are related to the Limiting requests feature :</p> Setting Default Context Multiple Description <code>USE_LIMIT_REQ</code> <code>yes</code> multisite no Activate limit requests feature. <code>LIMIT_REQ_URL</code> <code>/</code> multisite yes URL (PCRE regex) where the limit request will be applied or special value / for all requests. <code>LIMIT_REQ_RATE</code> <code>2r/s</code> multisite yes Rate to apply to the URL (s for second, m for minute, h for hour and d for day). <code>USE_LIMIT_CONN</code> <code>yes</code> multisite no Activate limit connections feature. <code>LIMIT_CONN_MAX_HTTP1</code> <code>10</code> multisite no Maximum number of connections per IP when using HTTP/1.X protocol. <code>LIMIT_CONN_MAX_HTTP2</code> <code>100</code> multisite no Maximum number of streams per IP when using HTTP/2 protocol. <code>LIMIT_CONN_MAX_STREAM</code> <code>10</code> multisite no Maximum number of connections per IP when using stream. <p>Please note that you can add different rates for different URLs by adding a number as a suffix to the settings for example : <code>LIMIT_REQ_URL_1=^/url1$</code>, <code>LIMIT_REQ_RATE_1=5r/d</code>, <code>LIMIT_REQ_URL_2=^/url2/subdir/.*$</code>, <code>LIMIT_REQ_RATE_2=1r/m</code>, ...</p> <p>Another important thing to note is that <code>LIMIT_REQ_URL</code> values are PCRE regex.</p>"},{"location":"security-tuning/#country","title":"Country","text":"<p>STREAM support </p> <p>The country security feature allows you to apply policy based on the country of the IP address of clients :</p> <ul> <li>Deny any access if the country is in a blacklist</li> <li>Only allow access if the country is in a whitelist (other security checks will still be executed)</li> </ul> <p>Here is the list of related settings :</p> Setting Default Description <code>BLACKLIST_COUNTRY</code> List of 2 letters country code to blacklist. <code>WHITELIST_COUNTRY</code> List of 2 letters country code to whitelist. <p>Using both country blacklist and whitelist at the same time makes no sense. If you do, please note that only the whitelist will be executed.</p>"},{"location":"security-tuning/#authentication","title":"Authentication","text":""},{"location":"security-tuning/#auth-basic","title":"Auth basic","text":"<p>STREAM support </p> <p>You can quickly protect sensitive resources like the admin area for example, by requiring HTTP basic authentication. Here is the list of related settings :</p> Setting Default Description <code>USE_AUTH_BASIC</code> <code>no</code> When set to <code>yes</code> HTTP auth basic will be enabled. <code>AUTH_BASIC_LOCATION</code> <code>sitewide</code> Location (URL) of the sensitive resource. Use special value <code>sitewide</code> to enable everywhere. <code>AUTH_BASIC_USER</code> <code>changeme</code> The username required. <code>AUTH_BASIC_PASSWORD</code> <code>changeme</code> The password required. <code>AUTH_BASIC_TEXT</code> <code>Restricted area</code> Text to display in the auth prompt."},{"location":"security-tuning/#auth-request","title":"Auth request","text":"<p>You can deploy complex authentication (e.g. SSO), by using the auth request settings (see here for more information on the feature). Please note that you will find Authelia and Authentik examples in the repository.</p> <p>Auth request settings are related to reverse proxy rules.</p> Setting Default Context Multiple Description <code>REVERSE_PROXY_AUTH_REQUEST</code> multisite yes Enable authentication using an external provider (value of auth_request directive). <code>REVERSE_PROXY_AUTH_REQUEST_SIGNIN_URL</code> multisite yes Redirect clients to sign-in URL when using REVERSE_PROXY_AUTH_REQUEST (used when auth_request call returned 401). <code>REVERSE_PROXY_AUTH_REQUEST_SET</code> multisite yes List of variables to set from the authentication provider, separated with ; (values of auth_request_set directives)."},{"location":"settings/","title":"Settings","text":"<p>Settings generator tool</p> <p>To help you tune BunkerWeb, we have made an easy-to-use settings generator tool available at config.bunkerweb.io.</p> <p>This section contains the full list of settings supported by BunkerWeb. If you are not yet familiar with BunkerWeb, you should first read the concepts section of the documentation. Please follow the instructions for your own integration on how to apply the settings.</p> <p>As a general rule when multisite mode is enabled, if you want to apply settings with multisite context to a specific server, you will need to add the primary (first) server name as a prefix like <code>www.example.com_USE_ANTIBOT=captcha</code> or <code>myapp.example.com_USE_GZIP=yes</code> for example.</p> <p>When settings are considered as \"multiple\", it means that you can have multiple groups of settings for the same feature by adding numbers as suffix like <code>REVERSE_PROXY_URL_1=/subdir</code>, <code>REVERSE_PROXY_HOST_1=http://myhost1</code>, <code>REVERSE_PROXY_URL_2=/anotherdir</code>, <code>REVERSE_PROXY_HOST_2=http://myhost2</code>, ... for example.</p>"},{"location":"settings/#global-settings","title":"Global settings","text":"<p>STREAM support </p> Setting Default Context Multiple Description <code>IS_LOADING</code> <code>no</code> global no Internal use : set to yes when BW is loading. <code>NGINX_PREFIX</code> <code>/etc/nginx/</code> global no Where nginx will search for configurations. <code>HTTP_PORT</code> <code>8080</code> global no HTTP port number which bunkerweb binds to. <code>HTTPS_PORT</code> <code>8443</code> global no HTTPS port number which bunkerweb binds to. <code>MULTISITE</code> <code>no</code> global no Multi site activation. <code>SERVER_NAME</code> <code>www.example.com</code> multisite no List of the virtual hosts served by bunkerweb. <code>WORKER_PROCESSES</code> <code>auto</code> global no Number of worker processes. <code>WORKER_RLIMIT_NOFILE</code> <code>2048</code> global no Maximum number of open files for worker processes. <code>WORKER_CONNECTIONS</code> <code>1024</code> global no Maximum number of connections per worker. <code>LOG_FORMAT</code> <code>$host $remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\"</code> global no The format to use for access logs. <code>LOG_LEVEL</code> <code>notice</code> global no The level to use for error logs. <code>DNS_RESOLVERS</code> <code>127.0.0.11</code> global no DNS addresses of resolvers to use. <code>DATASTORE_MEMORY_SIZE</code> <code>64m</code> global no Size of the internal datastore. <code>CACHESTORE_MEMORY_SIZE</code> <code>64m</code> global no Size of the internal cachestore. <code>CACHESTORE_IPC_MEMORY_SIZE</code> <code>16m</code> global no Size of the internal cachestore (ipc). <code>CACHESTORE_MISS_MEMORY_SIZE</code> <code>16m</code> global no Size of the internal cachestore (miss). <code>CACHESTORE_LOCKS_MEMORY_SIZE</code> <code>16m</code> global no Size of the internal cachestore (locks). <code>USE_API</code> <code>yes</code> global no Activate the API to control BunkerWeb. <code>API_HTTP_PORT</code> <code>5000</code> global no Listen port number for the API. <code>API_LISTEN_IP</code> <code>0.0.0.0</code> global no Listen IP address for the API. <code>API_SERVER_NAME</code> <code>bwapi</code> global no Server name (virtual host) for the API. <code>API_WHITELIST_IP</code> <code>127.0.0.0/8</code> global no List of IP/network allowed to contact the API. <code>AUTOCONF_MODE</code> <code>no</code> global no Enable Autoconf Docker integration. <code>SWARM_MODE</code> <code>no</code> global no Enable Docker Swarm integration. <code>KUBERNETES_MODE</code> <code>no</code> global no Enable Kubernetes integration. <code>SERVER_TYPE</code> <code>http</code> multisite no Server type : http or stream. <code>LISTEN_STREAM</code> <code>yes</code> multisite no Enable listening for non-ssl (passthrough). <code>LISTEN_STREAM_PORT</code> <code>1337</code> multisite no Listening port for non-ssl (passthrough). <code>LISTEN_STREAM_PORT_SSL</code> <code>4242</code> multisite no Listening port for ssl (passthrough). <code>USE_UDP</code> <code>no</code> multisite no UDP listen instead of TCP (stream). <code>USE_IPV6</code> <code>no</code> global no Enable IPv6 connectivity."},{"location":"settings/#core-settings","title":"Core settings","text":""},{"location":"settings/#antibot","title":"Antibot","text":"<p>STREAM support </p> <p>Bot detection by using a challenge.</p> Setting Default Context Multiple Description <code>USE_ANTIBOT</code> <code>no</code> multisite no Activate antibot feature. <code>ANTIBOT_URI</code> <code>/challenge</code> multisite no Unused URI that clients will be redirected to to solve the challenge. <code>ANTIBOT_RECAPTCHA_SCORE</code> <code>0.7</code> multisite no Minimum score required for reCAPTCHA challenge. <code>ANTIBOT_RECAPTCHA_SITEKEY</code> multisite no Sitekey for reCAPTCHA challenge. <code>ANTIBOT_RECAPTCHA_SECRET</code> multisite no Secret for reCAPTCHA challenge. <code>ANTIBOT_HCAPTCHA_SITEKEY</code> multisite no Sitekey for hCaptcha challenge. <code>ANTIBOT_HCAPTCHA_SECRET</code> multisite no Secret for hCaptcha challenge. <code>ANTIBOT_TURNSTILE_SITEKEY</code> multisite no Sitekey for Turnstile challenge. <code>ANTIBOT_TURNSTILE_SECRET</code> multisite no Secret for Turnstile challenge. <code>ANTIBOT_TIME_RESOLVE</code> <code>60</code> multisite no Maximum time (in seconds) clients have to resolve the challenge. Once this time has passed, a new challenge will be generated. <code>ANTIBOT_TIME_VALID</code> <code>86400</code> multisite no Maximum validity time of solved challenges. Once this time has passed, clients will need to resolve a new one."},{"location":"settings/#auth-basic","title":"Auth basic","text":"<p>STREAM support </p> <p>Enforce login before accessing a resource or the whole site using HTTP basic auth method.</p> Setting Default Context Multiple Description <code>USE_AUTH_BASIC</code> <code>no</code> multisite no Use HTTP basic auth <code>AUTH_BASIC_LOCATION</code> <code>sitewide</code> multisite no URL of the protected resource or sitewide value. <code>AUTH_BASIC_USER</code> <code>changeme</code> multisite no Username <code>AUTH_BASIC_PASSWORD</code> <code>changeme</code> multisite no Password <code>AUTH_BASIC_TEXT</code> <code>Restricted area</code> multisite no Text to display"},{"location":"settings/#bad-behavior","title":"Bad behavior","text":"<p>STREAM support </p> <p>Ban IP generating too much 'bad' HTTP status code in a period of time.</p> Setting Default Context Multiple Description <code>USE_BAD_BEHAVIOR</code> <code>yes</code> multisite no Activate Bad behavior feature. <code>BAD_BEHAVIOR_STATUS_CODES</code> <code>400 401 403 404 405 429 444</code> multisite no List of HTTP status codes considered as 'bad'. <code>BAD_BEHAVIOR_BAN_TIME</code> <code>86400</code> multisite no The duration time (in seconds) of a ban when the corresponding IP has reached the threshold. <code>BAD_BEHAVIOR_THRESHOLD</code> <code>10</code> multisite no Maximum number of 'bad' HTTP status codes within the period of time before IP is banned. <code>BAD_BEHAVIOR_COUNT_TIME</code> <code>60</code> multisite no Period of time (in seconds) during which we count 'bad' HTTP status codes."},{"location":"settings/#blacklist","title":"Blacklist","text":"<p>STREAM support </p> <p>Deny access based on internal and external IP/network/rDNS/ASN blacklists.</p> Setting Default Context Multiple Description <code>USE_BLACKLIST</code> <code>yes</code> multisite no Activate blacklist feature. <code>BLACKLIST_IP</code> multisite no List of IP/network, separated with spaces, to block. <code>BLACKLIST_IP_URLS</code> <code>https://www.dan.me.uk/torlist/?exit</code> global no List of URLs, separated with spaces, containing bad IP/network to block. <code>BLACKLIST_RDNS_GLOBAL</code> <code>yes</code> multisite no Only perform RDNS blacklist checks on global IP addresses. <code>BLACKLIST_RDNS</code> <code>.shodan.io .censys.io</code> multisite no List of reverse DNS suffixes, separated with spaces, to block. <code>BLACKLIST_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to block. <code>BLACKLIST_ASN</code> multisite no List of ASN numbers, separated with spaces, to block. <code>BLACKLIST_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to block. <code>BLACKLIST_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to block. <code>BLACKLIST_USER_AGENT_URLS</code> <code>https://raw.githubusercontent.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker/master/_generator_lists/bad-user-agents.list</code> global no List of URLs, separated with spaces, containing bad User-Agent to block. <code>BLACKLIST_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to block. <code>BLACKLIST_URI_URLS</code> global no List of URLs, separated with spaces, containing bad URI to block. <code>BLACKLIST_IGNORE_IP</code> multisite no List of IP/network, separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_IP_URLS</code> global no List of URLs, separated with spaces, containing IP/network to ignore in the blacklist. <code>BLACKLIST_IGNORE_RDNS</code> multisite no List of reverse DNS suffixes, separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to ignore in the blacklist. <code>BLACKLIST_IGNORE_ASN</code> multisite no List of ASN numbers, separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to ignore in the blacklist. <code>BLACKLIST_IGNORE_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_USER_AGENT_URLS</code> global no List of URLs, separated with spaces, containing User-Agent to ignore in the blacklist. <code>BLACKLIST_IGNORE_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to ignore in the blacklist. <code>BLACKLIST_IGNORE_URI_URLS</code> global no List of URLs, separated with spaces, containing URI to ignore in the blacklist."},{"location":"settings/#brotli","title":"Brotli","text":"<p>STREAM support </p> <p>Compress HTTP requests with the brotli algorithm.</p> Setting Default Context Multiple Description <code>USE_BROTLI</code> <code>no</code> multisite no Use brotli <code>BROTLI_TYPES</code> <code>application/atom+xml application/javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-opentype application/x-font-truetype application/x-font-ttf application/x-javascript application/xhtml+xml application/xml font/eot font/opentype font/otf font/truetype image/svg+xml image/vnd.microsoft.icon image/x-icon image/x-win-bitmap text/css text/javascript text/plain text/xml</code> multisite no List of MIME types that will be compressed with brotli. <code>BROTLI_MIN_LENGTH</code> <code>1000</code> multisite no Minimum length for brotli compression. <code>BROTLI_COMP_LEVEL</code> <code>6</code> multisite no The compression level of the brotli algorithm."},{"location":"settings/#bunkernet","title":"BunkerNet","text":"<p>STREAM support </p> <p>Share threat data with other BunkerWeb instances via BunkerNet.</p> Setting Default Context Multiple Description <code>USE_BUNKERNET</code> <code>yes</code> multisite no Activate BunkerNet feature. <code>BUNKERNET_SERVER</code> <code>https://api.bunkerweb.io</code> global no Address of the BunkerNet API."},{"location":"settings/#cors","title":"CORS","text":"<p>STREAM support </p> <p>Cross-Origin Resource Sharing.</p> Setting Default Context Multiple Description <code>USE_CORS</code> <code>no</code> multisite no Use CORS <code>CORS_ALLOW_ORIGIN</code> <code>*</code> multisite no Allowed origins to make CORS requests : PCRE regex or *. <code>CORS_EXPOSE_HEADERS</code> <code>Content-Length,Content-Range</code> multisite no Value of the Access-Control-Expose-Headers header. <code>CROSS_ORIGIN_OPENER_POLICY</code> multisite no Value for the Cross-Origin-Opener-Policy header. <code>CROSS_ORIGIN_EMBEDDER_POLICY</code> multisite no Value for the Cross-Origin-Embedder-Policy header. <code>CROSS_ORIGIN_RESOURCE_POLICY</code> multisite no Value for the Cross-Origin-Resource-Policy header. <code>CORS_MAX_AGE</code> <code>86400</code> multisite no Value of the Access-Control-Max-Age header. <code>CORS_ALLOW_CREDENTIALS</code> <code>no</code> multisite no Send the Access-Control-Allow-Credentials header. <code>CORS_ALLOW_METHODS</code> <code>GET, POST, OPTIONS</code> multisite no Value of the Access-Control-Allow-Methods header. <code>CORS_ALLOW_HEADERS</code> <code>DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range</code> multisite no Value of the Access-Control-Allow-Headers header. <code>CORS_DENY_REQUEST</code> <code>yes</code> multisite no Deny request and don't send it to backend if Origin is not allowed."},{"location":"settings/#client-cache","title":"Client cache","text":"<p>STREAM support </p> <p>Manage caching for clients.</p> Setting Default Context Multiple Description <code>USE_CLIENT_CACHE</code> <code>no</code> multisite no Tell client to store locally static files. <code>CLIENT_CACHE_EXTENSIONS</code> <code>jpg|jpeg|png|bmp|ico|svg|tif|css|js|otf|ttf|eot|woff|woff2</code> global no List of file extensions, separated with pipes that should be cached. <code>CLIENT_CACHE_ETAG</code> <code>yes</code> multisite no Send the HTTP ETag header for static resources. <code>CLIENT_CACHE_CONTROL</code> <code>public, max-age=15552000</code> multisite no Value of the Cache-Control HTTP header."},{"location":"settings/#country","title":"Country","text":"<p>STREAM support </p> <p>Deny access based on the country of the client IP.</p> Setting Default Context Multiple Description <code>BLACKLIST_COUNTRY</code> multisite no Deny access if the country of the client is in the list (2 letters code). <code>WHITELIST_COUNTRY</code> multisite no Deny access if the country of the client is not in the list (2 letters code)."},{"location":"settings/#custom-https-certificate","title":"Custom HTTPS certificate","text":"<p>STREAM support </p> <p>Choose custom certificate for HTTPS.</p> Setting Default Context Multiple Description <code>USE_CUSTOM_SSL</code> <code>no</code> multisite no Use custom HTTPS certificate. <code>CUSTOM_SSL_CERT</code> multisite no Full path of the certificate or bundle file (must be readable by the scheduler). <code>CUSTOM_SSL_KEY</code> multisite no Full path of the key file (must be readable by the scheduler)."},{"location":"settings/#db","title":"DB","text":"<p>STREAM support </p> <p>Integrate easily the Database.</p> Setting Default Context Multiple Description <code>DATABASE_URI</code> <code>sqlite:////var/lib/bunkerweb/db.sqlite3</code> global no The database URI, following the sqlalchemy format."},{"location":"settings/#dnsbl","title":"DNSBL","text":"<p>STREAM support </p> <p>Deny access based on external DNSBL servers.</p> Setting Default Context Multiple Description <code>USE_DNSBL</code> <code>yes</code> multisite no Activate DNSBL feature. <code>DNSBL_LIST</code> <code>bl.blocklist.de problems.dnsbl.sorbs.net sbl.spamhaus.org xbl.spamhaus.org</code> global no List of DNSBL servers."},{"location":"settings/#errors","title":"Errors","text":"<p>STREAM support </p> <p>Manage default error pages</p> Setting Default Context Multiple Description <code>ERRORS</code> multisite no List of HTTP error code and corresponding error pages, separated with spaces (404=/my404.html 403=/errors/403.html ...). <code>INTERCEPTED_ERROR_CODES</code> <code>400 401 403 404 405 413 429 500 501 502 503 504</code> multisite no List of HTTP error code intercepted by Bunkerweb"},{"location":"settings/#greylist","title":"Greylist","text":"<p>STREAM support </p> <p>Allow access while keeping security features based on internal and external IP/network/rDNS/ASN greylists.</p> Setting Default Context Multiple Description <code>USE_GREYLIST</code> <code>no</code> multisite no Activate greylist feature. <code>GREYLIST_IP</code> multisite no List of IP/network, separated with spaces, to put into the greylist. <code>GREYLIST_IP_URLS</code> global no List of URLs, separated with spaces, containing good IP/network to put into the greylist. <code>GREYLIST_RDNS_GLOBAL</code> <code>yes</code> multisite no Only perform RDNS greylist checks on global IP addresses. <code>GREYLIST_RDNS</code> multisite no List of reverse DNS suffixes, separated with spaces, to put into the greylist. <code>GREYLIST_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to put into the greylist. <code>GREYLIST_ASN</code> multisite no List of ASN numbers, separated with spaces, to put into the greylist. <code>GREYLIST_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to put into the greylist. <code>GREYLIST_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to put into the greylist. <code>GREYLIST_USER_AGENT_URLS</code> global no List of URLs, separated with spaces, containing good User-Agent to put into the greylist. <code>GREYLIST_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to put into the greylist. <code>GREYLIST_URI_URLS</code> global no List of URLs, separated with spaces, containing bad URI to put into the greylist."},{"location":"settings/#gzip","title":"Gzip","text":"<p>STREAM support </p> <p>Compress HTTP requests with the gzip algorithm.</p> Setting Default Context Multiple Description <code>USE_GZIP</code> <code>no</code> multisite no Use gzip <code>GZIP_TYPES</code> <code>application/atom+xml application/javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-opentype application/x-font-truetype application/x-font-ttf application/x-javascript application/xhtml+xml application/xml font/eot font/opentype font/otf font/truetype image/svg+xml image/vnd.microsoft.icon image/x-icon image/x-win-bitmap text/css text/javascript text/plain text/xml</code> multisite no List of MIME types that will be compressed with gzip. <code>GZIP_MIN_LENGTH</code> <code>1000</code> multisite no Minimum length for gzip compression. <code>GZIP_COMP_LEVEL</code> <code>5</code> multisite no The compression level of the gzip algorithm."},{"location":"settings/#html-injection","title":"HTML injection","text":"<p>STREAM support </p> <p>Inject custom HTML code before the  tag.</p> Setting Default Context Multiple Description <code>INJECT_BODY</code> multisite no The HTML code to inject."},{"location":"settings/#headers","title":"Headers","text":"<p>STREAM support </p> <p>Manage HTTP headers sent to clients.</p> Setting Default Context Multiple Description <code>CUSTOM_HEADER</code> multisite yes Custom header to add (HeaderName: HeaderValue). <code>REMOVE_HEADERS</code> <code>Server Expect-CT X-Powered-By X-AspNet-Version X-AspNetMvc-Version</code> multisite no Headers to remove (Header1 Header2 Header3 ...) <code>KEEP_UPSTREAM_HEADERS</code> <code>Content-Security-Policy Permissions-Policy Feature-Policy X-Frame-Options</code> multisite no Headers to keep from upstream (Header1 Header2 Header3 ... or * for all). <code>STRICT_TRANSPORT_SECURITY</code> <code>max-age=31536000</code> multisite no Value for the Strict-Transport-Security header. <code>COOKIE_FLAGS</code> <code>* HttpOnly SameSite=Lax</code> multisite yes Cookie flags automatically added to all cookies (value accepted for nginx_cookie_flag_module). <code>COOKIE_AUTO_SECURE_FLAG</code> <code>yes</code> multisite no Automatically add the Secure flag to all cookies. <code>CONTENT_SECURITY_POLICY</code> <code>object-src 'none'; form-action 'self'; frame-ancestors 'self';</code> multisite no Value for the Content-Security-Policy header. <code>CONTENT_SECURITY_POLICY_REPORT_ONLY</code> <code>no</code> multisite no Send reports for violations of the Content-Security-Policy header instead of blocking them. <code>REFERRER_POLICY</code> <code>strict-origin-when-cross-origin</code> multisite no Value for the Referrer-Policy header. <code>PERMISSIONS_POLICY</code> <code>accelerometer=(), ambient-light-sensor=(), autoplay=(), battery=(), camera=(), cross-origin-isolated=(), display-capture=(), document-domain=(), encrypted-media=(), execution-while-not-rendered=(), execution-while-out-of-viewport=(), fullscreen=(), geolocation=(), gyroscope=(), hid=(), idle-detection=(), magnetometer=(), microphone=(), midi=(), navigation-override=(), payment=(), picture-in-picture=(), publickey-credentials-get=(), screen-wake-lock=(), serial=(), usb=(), web-share=(), xr-spatial-tracking=()</code> multisite no Value for the Permissions-Policy header. <code>FEATURE_POLICY</code> <code>accelerometer 'none'; ambient-light-sensor 'none'; autoplay 'none'; battery 'none'; camera 'none'; display-capture 'none'; document-domain 'none'; encrypted-media 'none'; execution-while-not-rendered 'none'; execution-while-out-of-viewport 'none'; fullscreen 'none'; geolocation 'none'; gyroscope 'none'; layout-animation 'none'; legacy-image-formats 'none'; magnetometer 'none'; microphone 'none'; midi 'none'; navigation-override 'none'; payment 'none'; picture-in-picture 'none'; publickey-credentials-get 'none'; speaker-selection 'none'; sync-xhr 'none'; unoptimized-images 'none'; unsized-media 'none'; usb 'none'; screen-wake-lock 'none'; web-share 'none'; xr-spatial-tracking 'none';</code> multisite no Value for the Feature-Policy header. <code>X_FRAME_OPTIONS</code> <code>SAMEORIGIN</code> multisite no Value for the X-Frame-Options header. <code>X_CONTENT_TYPE_OPTIONS</code> <code>nosniff</code> multisite no Value for the X-Content-Type-Options header. <code>X_XSS_PROTECTION</code> <code>1; mode=block</code> multisite no Value for the X-XSS-Protection header."},{"location":"settings/#lets-encrypt","title":"Let's Encrypt","text":"<p>STREAM support </p> <p>Automatic creation, renewal and configuration of Let's Encrypt certificates.</p> Setting Default Context Multiple Description <code>AUTO_LETS_ENCRYPT</code> <code>no</code> multisite no Activate automatic Let's Encrypt mode. <code>EMAIL_LETS_ENCRYPT</code> multisite no Email used for Let's Encrypt notification and in certificate. <code>USE_LETS_ENCRYPT_STAGING</code> <code>no</code> multisite no Use the staging environment for Let\u2019s Encrypt certificate generation. Useful when you are testing your deployments to avoid being rate limited in the production environment."},{"location":"settings/#limit","title":"Limit","text":"<p>STREAM support </p> <p>Limit maximum number of requests and connections.</p> Setting Default Context Multiple Description <code>USE_LIMIT_REQ</code> <code>yes</code> multisite no Activate limit requests feature. <code>LIMIT_REQ_URL</code> <code>/</code> multisite yes URL (PCRE regex) where the limit request will be applied or special value / for all requests. <code>LIMIT_REQ_RATE</code> <code>2r/s</code> multisite yes Rate to apply to the URL (s for second, m for minute, h for hour and d for day). <code>USE_LIMIT_CONN</code> <code>yes</code> multisite no Activate limit connections feature. <code>LIMIT_CONN_MAX_HTTP1</code> <code>10</code> multisite no Maximum number of connections per IP when using HTTP/1.X protocol. <code>LIMIT_CONN_MAX_HTTP2</code> <code>100</code> multisite no Maximum number of streams per IP when using HTTP/2 protocol. <code>LIMIT_CONN_MAX_STREAM</code> <code>10</code> multisite no Maximum number of connections per IP when using stream."},{"location":"settings/#miscellaneous","title":"Miscellaneous","text":"<p>STREAM support </p> <p>Miscellaneous settings.</p> Setting Default Context Multiple Description <code>DISABLE_DEFAULT_SERVER</code> <code>no</code> global no Close connection if the request vhost is unknown. <code>REDIRECT_HTTP_TO_HTTPS</code> <code>no</code> multisite no Redirect all HTTP request to HTTPS. <code>AUTO_REDIRECT_HTTP_TO_HTTPS</code> <code>yes</code> multisite no Try to detect if HTTPS is used and activate HTTP to HTTPS redirection if that's the case. <code>ALLOWED_METHODS</code> <code>GET|POST|HEAD</code> multisite no Allowed HTTP and WebDAV methods, separated with pipes to be sent by clients. <code>MAX_CLIENT_SIZE</code> <code>10m</code> multisite no Maximum body size (0 for infinite). <code>SERVE_FILES</code> <code>yes</code> multisite no Serve files from the local folder. <code>ROOT_FOLDER</code> multisite no Root folder containing files to serve (/var/www/html/{server_name} if unset). <code>SSL_PROTOCOLS</code> <code>TLSv1.2 TLSv1.3</code> multisite no The supported version of TLS. We recommend the default value TLSv1.2 TLSv1.3 for compatibility reasons. <code>HTTP2</code> <code>yes</code> multisite no Support HTTP2 protocol when HTTPS is enabled. <code>LISTEN_HTTP</code> <code>yes</code> multisite no Respond to (insecure) HTTP requests. <code>USE_OPEN_FILE_CACHE</code> <code>no</code> multisite no Enable open file cache feature <code>OPEN_FILE_CACHE</code> <code>max=1000 inactive=20s</code> multisite no Open file cache directive <code>OPEN_FILE_CACHE_ERRORS</code> <code>yes</code> multisite no Enable open file cache for errors <code>OPEN_FILE_CACHE_MIN_USES</code> <code>2</code> multisite no Enable open file cache minimum uses <code>OPEN_FILE_CACHE_VALID</code> <code>30s</code> multisite no Open file cache valid time <code>EXTERNAL_PLUGIN_URLS</code> global no List of external plugins URLs (direct download to .zip or .tar file) to download and install (URLs are separated with space). <code>DENY_HTTP_STATUS</code> <code>403</code> global no HTTP status code to send when the request is denied (403 or 444). When using 444, BunkerWeb will close the connection."},{"location":"settings/#modsecurity","title":"ModSecurity","text":"<p>STREAM support </p> <p>Management of the ModSecurity WAF.</p> Setting Default Context Multiple Description <code>USE_MODSECURITY</code> <code>yes</code> multisite no Enable ModSecurity WAF. <code>USE_MODSECURITY_CRS</code> <code>yes</code> multisite no Enable OWASP Core Rule Set. <code>MODSECURITY_SEC_AUDIT_ENGINE</code> <code>RelevantOnly</code> multisite no SecAuditEngine directive of ModSecurity. <code>MODSECURITY_SEC_RULE_ENGINE</code> <code>On</code> multisite no SecRuleEngine directive of ModSecurity. <code>MODSECURITY_SEC_AUDIT_LOG_PARTS</code> <code>ABCFHZ</code> multisite no SecAuditLogParts directive of ModSecurity."},{"location":"settings/#php","title":"PHP","text":"<p>STREAM support </p> <p>Manage local or remote PHP-FPM.</p> Setting Default Context Multiple Description <code>REMOTE_PHP</code> multisite no Hostname of the remote PHP-FPM instance. <code>REMOTE_PHP_PATH</code> multisite no Root folder containing files in the remote PHP-FPM instance. <code>LOCAL_PHP</code> multisite no Path to the PHP-FPM socket file. <code>LOCAL_PHP_PATH</code> multisite no Root folder containing files in the local PHP-FPM instance."},{"location":"settings/#real-ip","title":"Real IP","text":"<p>STREAM support </p> <p>Get real IP of clients when BunkerWeb is behind a reverse proxy / load balancer.</p> Setting Default Context Multiple Description <code>USE_REAL_IP</code> <code>no</code> multisite no Retrieve the real IP of client. <code>USE_PROXY_PROTOCOL</code> <code>no</code> multisite no Enable PROXY protocol communication. <code>REAL_IP_FROM</code> <code>192.168.0.0/16 172.16.0.0/12 10.0.0.0/8</code> multisite no List of trusted IPs / networks, separated with spaces, where proxied requests come from. <code>REAL_IP_FROM_URLS</code> global no List of URLs containing trusted IPs / networks, separated with spaces, where proxied requests come from. <code>REAL_IP_HEADER</code> <code>X-Forwarded-For</code> multisite no HTTP header containing the real IP or special value proxy_protocol for PROXY protocol. <code>REAL_IP_RECURSIVE</code> <code>yes</code> multisite no Perform a recursive search in the header container IP address."},{"location":"settings/#redirect","title":"Redirect","text":"<p>STREAM support </p> <p>Manage HTTP redirects.</p> Setting Default Context Multiple Description <code>REDIRECT_TO</code> multisite no Redirect a whole site to another one. <code>REDIRECT_TO_REQUEST_URI</code> <code>no</code> multisite no Append the requested URI to the redirect address. <code>REDIRECT_TO_STATUS_CODE</code> <code>301</code> multisite no Status code to send to client when redirecting."},{"location":"settings/#redis","title":"Redis","text":"<p>STREAM support </p> <p>Redis server configuration when using BunkerWeb in cluster mode.</p> Setting Default Context Multiple Description <code>USE_REDIS</code> <code>no</code> global no Activate Redis. <code>REDIS_HOST</code> global no Redis server IP or hostname. <code>REDIS_PORT</code> <code>6379</code> global no Redis server port. <code>REDIS_DATABASE</code> <code>0</code> global no Redis database number. <code>REDIS_SSL</code> <code>no</code> global no Use SSL/TLS connection with Redis server. <code>REDIS_TIMEOUT</code> <code>1000</code> global no Redis server timeout (in ms) for connect, read and write. <code>REDIS_KEEPALIVE_IDLE</code> <code>30000</code> global no Max idle time (in ms) before closing redis connection in the pool. <code>REDIS_KEEPALIVE_POOL</code> <code>10</code> global no Max number of redis connection(s) kept in the pool."},{"location":"settings/#reverse-proxy","title":"Reverse proxy","text":"<p>STREAM support </p> <p>Manage reverse proxy configurations.</p> Setting Default Context Multiple Description <code>USE_REVERSE_PROXY</code> <code>no</code> multisite no Activate reverse proxy mode. <code>REVERSE_PROXY_INTERCEPT_ERRORS</code> <code>yes</code> multisite no Intercept and rewrite errors. <code>REVERSE_PROXY_HOST</code> multisite yes Full URL of the proxied resource (proxy_pass). <code>REVERSE_PROXY_URL</code> multisite yes Location URL that will be proxied. <code>REVERSE_PROXY_WS</code> <code>no</code> multisite yes Enable websocket on the proxied resource. <code>REVERSE_PROXY_HEADERS</code> multisite yes List of HTTP headers to send to proxied resource separated with semicolons (values for proxy_set_header directive). <code>REVERSE_PROXY_HEADERS_CLIENT</code> multisite yes List of HTTP headers to send to client separated with semicolons (values for add_header directive). <code>REVERSE_PROXY_BUFFERING</code> <code>yes</code> multisite yes Enable or disable buffering of responses from proxied resource. <code>REVERSE_PROXY_KEEPALIVE</code> <code>no</code> multisite yes Enable or disable keepalive connections with the proxied resource. <code>REVERSE_PROXY_AUTH_REQUEST</code> multisite yes Enable authentication using an external provider (value of auth_request directive). <code>REVERSE_PROXY_AUTH_REQUEST_SIGNIN_URL</code> multisite yes Redirect clients to sign-in URL when using REVERSE_PROXY_AUTH_REQUEST (used when auth_request call returned 401). <code>REVERSE_PROXY_AUTH_REQUEST_SET</code> multisite yes List of variables to set from the authentication provider, separated with semicolons (values of auth_request_set directives). <code>USE_PROXY_CACHE</code> <code>no</code> multisite no Enable or disable caching of the proxied resources. <code>PROXY_CACHE_PATH_LEVELS</code> <code>1:2</code> global no Hierarchy levels of the cache. <code>PROXY_CACHE_PATH_ZONE_SIZE</code> <code>10m</code> global no Maximum size of cached metadata when caching proxied resources. <code>PROXY_CACHE_PATH_PARAMS</code> <code>max_size=100m</code> global no Additional parameters to add to the proxy_cache directive. <code>PROXY_CACHE_METHODS</code> <code>GET HEAD</code> multisite no HTTP methods that should trigger a cache operation. <code>PROXY_CACHE_MIN_USES</code> <code>2</code> multisite no The minimum number of requests before a response is cached. <code>PROXY_CACHE_KEY</code> <code>$scheme$host$request_uri</code> multisite no The key used to uniquely identify a cached response. <code>PROXY_CACHE_VALID</code> <code>200=24h 301=1h 302=24h</code> multisite no Define the caching time depending on the HTTP status code (list of status=time), separated with spaces. <code>PROXY_NO_CACHE</code> <code>$http_pragma $http_authorization</code> multisite no Conditions to disable caching of responses. <code>PROXY_CACHE_BYPASS</code> <code>0</code> multisite no Conditions to bypass caching of responses. <code>REVERSE_PROXY_CONNECT_TIMEOUT</code> <code>60s</code> multisite yes Timeout when connecting to the proxied resource. <code>REVERSE_PROXY_READ_TIMEOUT</code> <code>60s</code> multisite yes Timeout when reading from the proxied resource. <code>REVERSE_PROXY_SEND_TIMEOUT</code> <code>60s</code> multisite yes Timeout when sending to the proxied resource."},{"location":"settings/#reverse-scan","title":"Reverse scan","text":"<p>STREAM support </p> <p>Scan clients ports to detect proxies or servers.</p> Setting Default Context Multiple Description <code>USE_REVERSE_SCAN</code> <code>no</code> multisite no Enable scanning of clients ports and deny access if one is opened. <code>REVERSE_SCAN_PORTS</code> <code>22 80 443 3128 8000 8080</code> multisite no List of port to scan when using reverse scan feature. <code>REVERSE_SCAN_TIMEOUT</code> <code>500</code> multisite no Specify the maximum timeout (in ms) when scanning a port."},{"location":"settings/#self-signed-certificate","title":"Self-signed certificate","text":"<p>STREAM support </p> <p>Generate self-signed certificate.</p> Setting Default Context Multiple Description <code>GENERATE_SELF_SIGNED_SSL</code> <code>no</code> multisite no Generate and use self-signed certificate. <code>SELF_SIGNED_SSL_EXPIRY</code> <code>365</code> multisite no Self-signed certificate expiry in days. <code>SELF_SIGNED_SSL_SUBJ</code> <code>/CN=www.example.com/</code> multisite no Self-signed certificate subject."},{"location":"settings/#sessions","title":"Sessions","text":"<p>STREAM support </p> <p>Management of session used by other plugins.</p> Setting Default Context Multiple Description <code>SESSIONS_SECRET</code> <code>random</code> global no Secret used to encrypt sessions variables for storing data related to challenges. <code>SESSIONS_NAME</code> <code>random</code> global no Name of the cookie given to clients. <code>SESSIONS_IDLING_TIMEOUT</code> <code>1800</code> global no Maximum time (in seconds) of inactivity before the session is invalidated. <code>SESSIONS_ROLLING_TIMEOUT</code> <code>3600</code> global no Maximum time (in seconds) before a session must be renewed. <code>SESSIONS_ABSOLUTE_TIMEOUT</code> <code>86400</code> global no Maximum time (in seconds) before a session is destroyed. <code>SESSIONS_CHECK_IP</code> <code>yes</code> global no Destroy session if IP address is different than original one. <code>SESSIONS_CHECK_USER_AGENT</code> <code>yes</code> global no Destroy session if User-Agent is different than original one."},{"location":"settings/#ui","title":"UI","text":"<p>STREAM support </p> <p>Integrate easily the BunkerWeb UI.</p> Setting Default Context Multiple Description <code>USE_UI</code> <code>no</code> multisite no Use UI"},{"location":"settings/#whitelist","title":"Whitelist","text":"<p>STREAM support </p> <p>Allow access based on internal and external IP/network/rDNS/ASN whitelists.</p> Setting Default Context Multiple Description <code>USE_WHITELIST</code> <code>yes</code> multisite no Activate whitelist feature. <code>WHITELIST_IP</code> <code>20.191.45.212 40.88.21.235 40.76.173.151 40.76.163.7 20.185.79.47 52.142.26.175 20.185.79.15 52.142.24.149 40.76.162.208 40.76.163.23 40.76.162.191 40.76.162.247</code> multisite no List of IP/network, separated with spaces, to put into the whitelist. <code>WHITELIST_IP_URLS</code> global no List of URLs, separated with spaces, containing good IP/network to whitelist. <code>WHITELIST_RDNS_GLOBAL</code> <code>yes</code> multisite no Only perform RDNS whitelist checks on global IP addresses. <code>WHITELIST_RDNS</code> <code>.google.com .googlebot.com .yandex.ru .yandex.net .yandex.com .search.msn.com .baidu.com .baidu.jp .crawl.yahoo.net .fwd.linkedin.com .twitter.com .twttr.com .discord.com</code> multisite no List of reverse DNS suffixes, separated with spaces, to whitelist. <code>WHITELIST_RDNS_URLS</code> global no List of URLs, separated with spaces, containing reverse DNS suffixes to whitelist. <code>WHITELIST_ASN</code> <code>32934</code> multisite no List of ASN numbers, separated with spaces, to whitelist. <code>WHITELIST_ASN_URLS</code> global no List of URLs, separated with spaces, containing ASN to whitelist. <code>WHITELIST_USER_AGENT</code> multisite no List of User-Agent (PCRE regex), separated with spaces, to whitelist. <code>WHITELIST_USER_AGENT_URLS</code> global no List of URLs, separated with spaces, containing good User-Agent to whitelist. <code>WHITELIST_URI</code> multisite no List of URI (PCRE regex), separated with spaces, to whitelist. <code>WHITELIST_URI_URLS</code> global no List of URLs, separated with spaces, containing bad URI to whitelist."},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#logs","title":"Logs","text":"<p>When troubleshooting, logs are your best friends. We try our best to provide user-friendly logs to help you understand what's happening.</p> <p>Please note that you can set <code>LOG_LEVEL</code> setting to <code>info</code> (default : <code>notice</code>) to increase the verbosity of BunkerWeb.</p> <p>Here is how you can access the logs, depending on your integration :</p> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>List containers</p> <p>To list the running containers, you can use the following command : <pre><code>docker ps\n</code></pre></p> <p>You can use the <code>docker logs</code> command (replace <code>mybunker</code> with the name of your container) : <pre><code>docker logs mybunker\n</code></pre></p> <p>Here is the docker-compose equivalent (replace <code>mybunker</code> with the name of the services declared in the docker-compose.yml file) : <pre><code>docker-compose logs mybunker\n</code></pre></p> <p>List containers</p> <p>To list the running containers, you can use the following command : <pre><code>docker ps\n</code></pre></p> <p>You can use the <code>docker logs</code> command (replace <code>mybunker</code> and <code>myautoconf</code> with the name of your containers) : <pre><code>docker logs mybunker\ndocker logs myautoconf\n</code></pre></p> <p>Here is the docker-compose equivalent (replace <code>mybunker</code> and <code>myautoconf</code> with the name of the services declared in the docker-compose.yml file) : <pre><code>docker-compose logs mybunker\ndocker-compose logs myautoconf\n</code></pre></p> <p>List services</p> <p>To list the services, you can use the following command : <pre><code>docker service ls\n</code></pre></p> <p>You can use the <code>docker service logs</code> command (replace <code>mybunker</code> and <code>myautoconf</code> with the name of your services) : <pre><code>docker service logs mybunker\ndocker service logs myautoconf\n</code></pre></p> <p>List pods</p> <p>To list the pods, you can use the following command : <pre><code>kubectl get pods\n</code></pre></p> <p>You can use the <code>kubectl logs</code> command (replace <code>mybunker</code> and <code>myautoconf</code> with the name of your pods) : <pre><code>kubectl logs mybunker\nkubectl logs myautoconf\n</code></pre></p> <p>For errors related to BunkerWeb services (e.g. not starting), you can use <code>journalctl</code> : <pre><code>journalctl -u bunkerweb --no-pager\n</code></pre></p> <p>Common logs are located inside the <code>/var/log/bunkerweb</code> directory : <pre><code>cat /var/log/bunkerweb/error.log\ncat /var/log/bunkerweb/access.log\n</code></pre></p> <p>For errors related to BunkerWeb services (e.g. not starting), you can use <code>journalctl</code> : <pre><code>ansible -i inventory.yml all -a \"journalctl -u bunkerweb --no-pager\" --become\n</code></pre></p> <p>Common logs are located inside the <code>/var/log/bunkerweb</code> directory : <pre><code>ansible -i inventory.yml all -a \"cat /var/log/bunkerweb/error.log\" --become\nansible -i inventory.yml all -a \"cat /var/log/bunkerweb/access.log\" --become\n</code></pre></p> <p>For errors related to BunkerWeb services (e.g. not starting), you can use <code>journalctl</code> : <pre><code>journalctl -u bunkerweb --no-pager\n</code></pre></p> <p>Common logs are located inside the <code>/var/log/bunkerweb</code> directory : <pre><code>cat /var/log/bunkerweb/error.log\ncat /var/log/bunkerweb/access.log\n</code></pre></p>"},{"location":"troubleshooting/#permissions","title":"Permissions","text":"<p>Don't forget that BunkerWeb runs as an unprivileged user for obvious security reasons. Double-check the permissions of files and folders used by BunkerWeb, especially if you use custom configurations (more info here). You will need to set at least RW rights on files and RWX on folders.</p>"},{"location":"troubleshooting/#modsecurity","title":"ModSecurity","text":"<p>The default BunkerWeb configuration of ModSecurity is to load the Core Rule Set in anomaly scoring mode with a paranoia level (PL) of 1 :</p> <ul> <li>Each matched rule will increase an anomaly score (so many rules can match a single request)</li> <li>PL1 includes rules with fewer chances of false positives (but less security than PL4)</li> <li>the default threshold for anomaly score is 5 for requests and 4 for responses</li> </ul> <p>Let's take the following logs as an example of ModSecurity detection using default configuration (formatted for better readability) :</p> <pre><code>2022/04/26 12:01:10 [warn] 85#85: *11 ModSecurity: Warning. Matched \"Operator `PmFromFile' with parameter `lfi-os-files.data' against variable `ARGS:id' (Value: `/etc/passwd' )\n    [file \"/usr/share/bunkerweb/core/modsecurity/files/coreruleset/rules/REQUEST-930-APPLICATION-ATTACK-LFI.conf\"]\n    [line \"78\"]\n    [id \"930120\"]\n    [rev \"\"]\n    [msg \"OS File Access Attempt\"]\n    [data \"Matched Data: etc/passwd found within ARGS:id: /etc/passwd\"]\n    [severity \"2\"]\n    [ver \"OWASP_CRS/3.3.2\"]\n    [maturity \"0\"]\n    [accuracy \"0\"]\n    [tag \"application-multi\"]\n    [tag \"language-multi\"]\n    [tag \"platform-multi\"]\n    [tag \"attack-lfi\"]\n    [tag \"paranoia-level/1\"]\n    [tag \"OWASP_CRS\"]\n    [tag \"capec/1000/255/153/126\"]\n    [tag \"PCI/6.5.4\"]\n    [hostname \"172.17.0.2\"]\n    [uri \"/\"]\n    [unique_id \"165097447014.179282\"]\n    [ref \"o1,10v9,11t:utf8toUnicode,t:urlDecodeUni,t:normalizePathWin,t:lowercase\"],\n    client: 172.17.0.1, server: localhost, request: \"GET /?id=/etc/passwd HTTP/1.1\", host: \"localhost\"\n2022/04/26 12:01:10 [warn] 85#85: *11 ModSecurity: Warning. Matched \"Operator `PmFromFile' with parameter `unix-shell.data' against variable `ARGS:id' (Value: `/etc/passwd' )\n    [file \"/usr/share/bunkerweb/core/modsecurity/files/coreruleset/rules/REQUEST-932-APPLICATION-ATTACK-RCE.conf\"]\n    [line \"480\"]\n    [id \"932160\"]\n    [rev \"\"]\n    [msg \"Remote Command Execution: Unix Shell Code Found\"]\n    [data \"Matched Data: etc/passwd found within ARGS:id: /etc/passwd\"]\n    [severity \"2\"]\n    [ver \"OWASP_CRS/3.3.2\"]\n    [maturity \"0\"]\n    [accuracy \"0\"]\n    [tag \"application-multi\"]\n    [tag \"language-shell\"]\n    [tag \"platform-unix\"]\n    [tag \"attack-rce\"]\n    [tag \"paranoia-level/1\"]\n    [tag \"OWASP_CRS\"]\n    [tag \"capec/1000/152/248/88\"]\n    [tag \"PCI/6.5.2\"]\n    [hostname \"172.17.0.2\"]\n    [uri \"/\"]\n    [unique_id \"165097447014.179282\"]\n    [ref \"o1,10v9,11t:urlDecodeUni,t:cmdLine,t:normalizePath,t:lowercase\"],\n    client: 172.17.0.1, server: localhost, request: \"GET /?id=/etc/passwd HTTP/1.1\", host: \"localhost\"\n2022/04/26 12:01:10 [error] 85#85: *11 [client 172.17.0.1] ModSecurity: Access denied with code 403 (phase 2). Matched \"Operator `Ge' with parameter `5' against variable `TX:ANOMALY_SCORE' (Value: `10' )\n    [file \"/usr/share/bunkerweb/core/modsecurity/files/coreruleset/rules/REQUEST-949-BLOCKING-EVALUATION.conf\"]\n    [line \"80\"]\n    [id \"949110\"]\n    [rev \"\"]\n    [msg \"Inbound Anomaly Score Exceeded (Total Score: 10)\"]\n    [data \"\"]\n    [severity \"2\"]\n    [ver \"OWASP_CRS/3.3.2\"]\n    [maturity \"0\"]\n    [accuracy \"0\"]\n    [tag \"application-multi\"]\n    [tag \"language-multi\"]\n    [tag \"platform-multi\"]\n    [tag \"attack-generic\"]\n    [hostname \"172.17.0.2\"]\n    [uri \"/\"]\n    [unique_id \"165097447014.179282\"]\n    [ref \"\"],\n    client: 172.17.0.1, server: localhost, request: \"GET /?id=/etc/passwd HTTP/1.1\", host: \"localhost\"\n</code></pre> <p>As we can see, there are 3 different logs :</p> <ol> <li>Rule 930120 matched</li> <li>Rule 932160 matched</li> <li>Access denied (rule 949110)</li> </ol> <p>One important thing to understand is that rule 949110 is not a \"real\" one : it's the one that will deny the request because the anomaly threshold is reached (which is 10 in this example). You should never remove the 949110 rule !</p> <p>If it's a false-positive, you should then focus on both 930120 and 932160 rules. ModSecurity and/or CRS tuning is out of the scope of this documentation but don't forget that you can apply custom configurations before and after the CRS is loaded (more info here).</p>"},{"location":"troubleshooting/#bad-behavior","title":"Bad Behavior","text":"<p>A common false-positive case is when the client is banned because of the \"bad behavior\" feature which means that too many suspicious HTTP status codes were generated within a time period (more info here). You should start by reviewing the settings and then edit them according to your web application(s) like removing a suspicious HTTP code, decreasing the count time, increasing the threshold, ...</p>"},{"location":"troubleshooting/#ip-unban","title":"IP unban","text":"<p>You can manually unban an IP which can be useful when doing some tests but it needs the setting <code>USE_API</code> set to <code>yes</code> (which is not the default) so you can contact the internal API of BunkerWeb (replace <code>1.2.3.4</code> with the IP address to unban) :</p> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>You can use the <code>docker exec</code> command (replace <code>mybunker</code> with the name of your container) : <pre><code>docker exec mybunker bwcli unban 1.2.3.4\n</code></pre></p> <p>Here is the docker-compose equivalent (replace <code>mybunker</code> with the name of the services declared in the docker-compose.yml file) : <pre><code>docker-compose exec mybunker bwcli unban 1.2.3.4\n</code></pre></p> <p>You can use the <code>docker exec</code> command (replace <code>myautoconf</code> with the name of your container) : <pre><code>docker exec myautoconf bwcli unban 1.2.3.4\n</code></pre></p> <p>Here is the docker-compose equivalent (replace <code>myautoconf</code> with the name of the services declared in the docker-compose.yml file) : <pre><code>docker-compose exec myautoconf bwcli unban 1.2.3.4\n</code></pre></p> <p>You can use the <code>docker exec</code> command (replace <code>myautoconf</code> with the name of your service) : <pre><code>docker exec $(docker ps -q -f name=myautoconf) bwcli unban 1.2.3.4\n</code></pre></p> <p>You can use the <code>kubectl exec</code> command (replace <code>myautoconf</code> with the name of your pod) : <pre><code>kubectl exec myautoconf bwcli unban 1.2.3.4\n</code></pre></p> <p>You can use the <code>bwcli</code> command (as root) : <pre><code>sudo bwcli unban 1.2.3.4\n</code></pre></p> <p>You can use the <code>bwcli</code> command : <pre><code>ansible -i inventory.yml all -a \"bwcli unban 1.2.3.4\" --become\n</code></pre></p> <p>You can use the <code>bwcli</code> command (as root) : <pre><code>sudo bwcli unban 1.2.3.4\n</code></pre></p>"},{"location":"troubleshooting/#whitelisting","title":"Whitelisting","text":"<p>If you have bots that need to access your website, the recommended way to avoid any false positive is to whitelist them using the whitelisting feature. We don't recommend using the <code>WHITELIST_URI*</code> or <code>WHITELIST_USER_AGENT*</code> settings unless they are set to secret and unpredictable values. Common use cases are :</p> <ul> <li>Healthcheck / status bot</li> <li>Callback like IPN or webhook</li> <li>Social media crawler</li> </ul>"},{"location":"troubleshooting/#timezone","title":"Timezone","text":"<p>When using container-based integrations, the timezone of the container may not match the one of the host machine. To resolve that, you can set the <code>TZ</code> environment variable to the timezone of your choice on your containers (e.g. <code>TZ=Europe/Paris</code>). You will find the list of timezone identifers here.</p>"},{"location":"web-ui/","title":"Web UI","text":""},{"location":"web-ui/#overview","title":"Overview","text":"<p>The \"Web UI\" is a web application that helps you manage your BunkerWeb instance using a user-friendly interface instead of the command-line one.</p>"},{"location":"web-ui/#features","title":"Features","text":"<ul> <li>Start, stop, restart and reload your BunkerWeb instance</li> <li>Add, edit and delete settings for your web applications</li> <li>Add, edit and delete custom configurations for NGINX and ModSecurity</li> <li>Install and uninstall external plugins</li> <li>Explore the cached files</li> <li>Monitor jobs execution</li> <li>View the logs and search pattern</li> </ul>"},{"location":"web-ui/#installation","title":"Installation","text":"<p>Because the web UI is a web application, the recommended installation procedure is to use BunkerWeb in front of it as a reverse proxy.</p> <p>Security considerations</p> <p>The security of the web UI is really important. If someone manages to gain access to the application, not only he will be able to edit your configurations but he could execute some code in the context of BunkerWeb (with a custom configuration containing LUA code for example). We highly recommend you to follow minimal security best practices like :</p> <ul> <li>Choose a strong password for the login (at least 8 chars with 1 lower case letter, 1 upper case letter, 1 digit and 1 special char is required)</li> <li>Put the web UI under a \"hard to guess\" URI</li> <li>Do not open the web UI on the Internet without any further restrictions</li> <li>Apply settings listed in the security tuning section of the documentation</li> </ul> <p>Multisite mode</p> <p>The usage of the web UI implies enabling the multisite mode.</p> DockerDocker autoconfSwarmKubernetesLinuxAnsibleVagrant <p>The web UI can be deployed using a dedicated container which is available on Docker Hub :</p> <pre><code>docker pull bunkerity/bunkerweb-ui\n</code></pre> <p>Alternatively, you can also build it yourself :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb.git &amp;&amp; \\\ncd bunkerweb &amp;&amp; \\\ndocker build -t my-bunkerweb-ui -f src/ui/Dockerfile .\n</code></pre> <p>The following environment variables are used to configure the web UI container :</p> <ul> <li><code>ADMIN_USERNAME</code> : username to access the web UI</li> <li><code>ADMIN_PASSWORD</code> : password to access the web UI</li> </ul> <p>Accessing the web UI through BunkerWeb is a classical reverse proxy setup. We recommend you to connect BunkerWeb and web UI using a dedicated network (like <code>bw-universe</code> also used by the scheduler) so it won't be on the same network of your web services for obvious security reasons. Please note that the web UI container is listening on the <code>7000</code> port.</p> <p>Database backend</p> <p>If you want another Database backend than MariaDB please refer to the docker-compose files in the misc/integrations folder of the repository.</p> <p>Here is the docker-compose boilerplate that you can use (don't forget to edit the <code>changeme</code> data) :</p> <pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080\n- 443:8443\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- SERVER_NAME=www.example.com\n- MULTISITE=yes\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\n- DISABLE_DEFAULT_SERVER=yes\n- USE_CLIENT_CACHE=yes\n- USE_GZIP=yes\n- www.example.com_USE_UI=yes\n- www.example.com_USE_REVERSE_PROXY=yes\n- www.example.com_REVERSE_PROXY_URL=/changeme\n- www.example.com_REVERSE_PROXY_HOST=http://bw-ui:7000\n- www.example.com_INTERCEPTED_ERROR_CODES=400 404 405 413 429 500 501 502 503 504\nnetworks:\n- bw-universe\n- bw-services\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nbw-ui:\nimage: bunkerity/bunkerweb-ui:1.5.1\ndepends_on:\n- bw-docker\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\n- DOCKER_HOST=tcp://bw-docker:2375\n- ADMIN_USERNAME=changeme\n- ADMIN_PASSWORD=changeme # Remember to set a stronger password for the changeme user\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-db:\nimage: mariadb:10.10\nenvironment:\n- MYSQL_RANDOM_ROOT_PASSWORD=yes\n- MYSQL_DATABASE=db\n- MYSQL_USER=bunkerweb\n- MYSQL_PASSWORD=changeme # Remember to set a stronger password for the database\nvolumes:\n- bw-data:/var/lib/mysql\nnetworks:\n- bw-docker\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>The web UI can be deployed using a dedicated container which is available on Docker Hub :</p> <pre><code>docker pull bunkerity/bunkerweb-ui\n</code></pre> <p>Alternatively, you can also build it yourself :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb.git &amp;&amp; \\\ncd bunkerweb &amp;&amp; \\\ndocker build -t my-bunkerweb-ui -f src/ui/Dockerfile .\n</code></pre> <p>The following environment variables are used to configure the web UI container :</p> <ul> <li><code>ADMIN_USERNAME</code> : username to access the web UI</li> <li><code>ADMIN_PASSWORD</code> : password to access the web UI</li> </ul> <p>Accessing the web UI through BunkerWeb is a classical reverse proxy setup. We recommend you to connect BunkerWeb and web UI using a dedicated network (like <code>bw-universe</code> also used by the scheduler and autoconf) so it won't be on the same network of your web services for obvious security reasons. Please note that the web UI container is listening on the <code>7000</code> port.</p> <p>Database backend</p> <p>If you want another Database backend than MariaDB please refer to the docker-compose files in the misc/integrations folder of the repository.</p> <p>Here is the docker-compose boilerplate that you can use (don't forget to edit the <code>changeme</code> data) :</p> <pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- 80:8080\n- 443:8443\nlabels:\n- \"bunkerweb.INSTANCE\"\nenvironment:\n- SERVER_NAME=\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- AUTOCONF_MODE=yes\n- MULTISITE=yes\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\nnetworks:\n- bw-universe\n- bw-services\n\nbw-autoconf:\nimage: bunkerity/bunkerweb-autoconf:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- AUTOCONF_MODE=yes\n- DOCKER_HOST=tcp://bw-docker:2375\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\ndepends_on:\n- bunkerweb\n- bw-docker\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- DOCKER_HOST=tcp://bw-docker:2375\n- AUTOCONF_MODE=yes\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONTAINERS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\n\nbw-db:\nimage: mariadb:10.10\nenvironment:\n- MYSQL_RANDOM_ROOT_PASSWORD=yes\n- MYSQL_DATABASE=db\n- MYSQL_USER=bunkerweb\n- MYSQL_PASSWORD=changeme\nvolumes:\n- bw-data:/var/lib/mysql\nnetworks:\n- bw-docker\n\nbw-ui:\nimage: bunkerity/bunkerweb-ui:1.5.1\nnetworks:\nbw-docker:\nbw-universe:\naliases:\n- bw-ui\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- DOCKER_HOST=tcp://bw-docker:2375\n- AUTOCONF_MODE=yes\n- ADMIN_USERNAME=admin\n- ADMIN_PASSWORD=changeme\nlabels:\n- \"bunkerweb.SERVER_NAME=www.example.com\"\n- \"bunkerweb.USE_UI=yes\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/changeme\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://bw-ui:7000\"\n- \"bunkerweb.INTERCEPTED_ERROR_CODES=400 404 405 413 429 500 501 502 503 504\"\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\nipam:\ndriver: default\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\nbw-docker:\nname: bw-docker\n</code></pre> <p>The web UI can be deployed using a dedicated container which is available on Docker Hub :</p> <pre><code>docker pull bunkerity/bunkerweb-ui\n</code></pre> <p>Alternatively, you can also build it yourself :</p> <pre><code>git clone https://github.com/bunkerity/bunkerweb.git &amp;&amp; \\\ncd bunkerweb &amp;&amp; \\\ndocker build -t my-bunkerweb-ui -f src/ui/Dockerfile .\n</code></pre> <p>The following environment variables are used to configure the web UI container :</p> <ul> <li><code>ADMIN_USERNAME</code> : username to access the web UI</li> <li><code>ADMIN_PASSWORD</code> : password to access the web UI</li> </ul> <p>Accessing the web UI through BunkerWeb is a classical reverse proxy setup. We recommend you to connect BunkerWeb and web UI using a dedicated network (like <code>bw-universe</code> also used by the scheduler and autoconf) so it won't be on the same network of your web services for obvious security reasons. Please note that the web UI container is listening on the <code>7000</code> port.</p> <p>Database backend</p> <p>If you want another Database backend than MariaDB please refer to the stack files in the misc/integrations folder of the repository.</p> <p>Here is the stack boilerplate that you can use (don't forget to edit the <code>changeme</code> data) :</p> <pre><code>version: \"3.5\"\n\nservices:\nbunkerweb:\nimage: bunkerity/bunkerweb:1.5.1\nports:\n- published: 80\ntarget: 8080\nmode: host\nprotocol: tcp\n- published: 443\ntarget: 8443\nmode: host\nprotocol: tcp\nenvironment:\n- SERVER_NAME=\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\n- SWARM_MODE=yes\n- MULTISITE=yes\n- USE_REDIS=yes\n- REDIS_HOST=bw-redis\n- API_WHITELIST_IP=127.0.0.0/8 10.20.30.0/24\nnetworks:\n- bw-universe\n- bw-services\ndeploy:\nmode: global\nplacement:\nconstraints:\n- \"node.role == worker\"\nlabels:\n- \"bunkerweb.INSTANCE\"\n\nbw-autoconf:\nimage: bunkerity/bunkerweb-autoconf:1.5.1\nenvironment:\n- SWARM_MODE=yes\n- DOCKER_HOST=tcp://bw-docker:2375\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-docker:\nimage: tecnativa/docker-socket-proxy:nightly\nvolumes:\n- /var/run/docker.sock:/var/run/docker.sock:ro\nenvironment:\n- CONFIGS=1\n- CONTAINERS=1\n- SERVICES=1\n- SWARM=1\n- TASKS=1\n- LOG_LEVEL=warning\nnetworks:\n- bw-docker\ndeploy:\nplacement:\nconstraints:\n- \"node.role == manager\"\n\nbw-scheduler:\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nenvironment:\n- SWARM_MODE=yes\n- DOCKER_HOST=tcp://bw-docker:2375\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db\nnetworks:\n- bw-universe\n- bw-docker\n\nbw-db:\nimage: mariadb:10.10\nenvironment:\n- MYSQL_RANDOM_ROOT_PASSWORD=yes\n- MYSQL_DATABASE=db\n- MYSQL_USER=bunkerweb\n- MYSQL_PASSWORD=changeme\nvolumes:\n- bw-data:/var/lib/mysql\nnetworks:\n- bw-docker\n\nbw-redis:\nimage: redis:7-alpine\nnetworks:\n- bw-universe\n\nbw-ui:\nimage: bunkerity/bunkerweb-ui:1.5.1\nenvironment:\n- DATABASE_URI=mariadb+pymysql://bunkerweb:changeme@bw-db:3306/db # Remember to set a stronger password for the database\n- DOCKER_HOST=tcp://bw-docker:2375\n- ADMIN_USERNAME=changeme\n- ADMIN_PASSWORD=changeme # Remember to set a stronger password for the changeme user\nnetworks:\n- bw-universe\n- bw-docker\ndeploy:\nlabels:\n- \"bunkerweb.SERVER_NAME=www.example.com\"\n- \"bunkerweb.USE_UI=yes\"\n- \"bunkerweb.USE_REVERSE_PROXY=yes\"\n- \"bunkerweb.REVERSE_PROXY_URL=/changeme\"\n- \"bunkerweb.REVERSE_PROXY_HOST=http://bw-ui:7000\"\n- \"bunkerweb.REVERSE_PROXY_INTERCEPT_ERRORS=no\"\n- \"bunkerweb.INTERCEPTED_ERROR_CODES=400 404 405 413 429 500 501 502 503 504\"\n\nvolumes:\nbw-data:\n\nnetworks:\nbw-universe:\nname: bw-universe\ndriver: overlay\nattachable: true\nipam:\nconfig:\n- subnet: 10.20.30.0/24\nbw-services:\nname: bw-services\ndriver: overlay\nattachable: true\nbw-docker:\nname: bw-docker\ndriver: overlay\nattachable: true\n</code></pre> <p>The web UI can be deployed using a dedicated container which is available on Docker Hub as a standard Deployment.</p> <p>The following environment variables are used to configure the web UI container :</p> <ul> <li><code>ADMIN_USERNAME</code> : username to access the web UI</li> <li><code>ADMIN_PASSWORD</code> : password to access the web UI</li> </ul> <p>Accessing the web UI through BunkerWeb is a classical reverse proxy setup. Network segmentation between web UI and web services is not covered in this documentation. Please note that the web UI container is listening on the <code>7000</code> port.</p> <p>Database backend</p> <p>If you want another Database backend than MariaDB please refer to the yaml files in the misc/integrations folder of the repository.</p> <p>Here is the yaml boilerplate that you can use (don't forget to edit the <code>changeme</code> data) :</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\nname: cr-bunkerweb\nrules:\n- apiGroups: [\"\"]\nresources: [\"services\", \"pods\", \"configmaps\"]\nverbs: [\"get\", \"watch\", \"list\"]\n- apiGroups: [\"networking.k8s.io\"]\nresources: [\"ingresses\"]\nverbs: [\"get\", \"watch\", \"list\"]\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: sa-bunkerweb\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: crb-bunkerweb\nsubjects:\n- kind: ServiceAccount\nname: sa-bunkerweb\nnamespace: default\napiGroup: \"\"\nroleRef:\nkind: ClusterRole\nname: cr-bunkerweb\napiGroup: rbac.authorization.k8s.io\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\nname: bunkerweb\nspec:\nselector:\nmatchLabels:\napp: bunkerweb\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb\n# mandatory annotation\nannotations:\nbunkerweb.io/INSTANCE: \"yes\"\nspec:\ncontainers:\n# using bunkerweb as name is mandatory\n- name: bunkerweb\nimage: bunkerity/bunkerweb:1.5.1\nimagePullPolicy: Always\nsecurityContext:\nrunAsUser: 101\nrunAsGroup: 101\nallowPrivilegeEscalation: false\ncapabilities:\ndrop:\n- ALL\nports:\n- containerPort: 8080\nhostPort: 80\n- containerPort: 8443\nhostPort: 443\nenv:\n- name: KUBERNETES_MODE\nvalue: \"yes\"\n# replace with your DNS resolvers\n# e.g. : kube-dns.kube-system.svc.cluster.local\n- name: DNS_RESOLVERS\nvalue: \"coredns.kube-system.svc.cluster.local\"\n- name: USE_API\nvalue: \"yes\"\n# 10.0.0.0/8 is the cluster internal subnet\n- name: API_WHITELIST_IP\nvalue: \"127.0.0.0/8 10.0.0.0/8\"\n- name: SERVER_NAME\nvalue: \"\"\n- name: MULTISITE\nvalue: \"yes\"\n- name: USE_REDIS\nvalue: \"yes\"\n- name: REDIS_HOST\nvalue: \"svc-bunkerweb-redis.default.svc.cluster.local\"\nlivenessProbe:\nexec:\ncommand:\n- /usr/share/bunkerweb/helpers/healthcheck.sh\ninitialDelaySeconds: 30\nperiodSeconds: 5\ntimeoutSeconds: 1\nfailureThreshold: 3\nreadinessProbe:\nexec:\ncommand:\n- /usr/share/bunkerweb/helpers/healthcheck.sh\ninitialDelaySeconds: 30\nperiodSeconds: 1\ntimeoutSeconds: 1\nfailureThreshold: 3\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-controller\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-controller\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-controller\nspec:\nserviceAccountName: sa-bunkerweb\ncontainers:\n- name: bunkerweb-controller\nimage: bunkerity/bunkerweb-autoconf:1.5.1\nimagePullPolicy: Always\nenv:\n- name: KUBERNETES_MODE\nvalue: \"yes\"\n- name: \"DATABASE_URI\"\nvalue: \"mariadb+pymysql://bunkerweb:changeme@svc-bunkerweb-db:3306/db\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-scheduler\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-scheduler\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-scheduler\nspec:\nserviceAccountName: sa-bunkerweb\ncontainers:\n- name: bunkerweb-scheduler\nimage: bunkerity/bunkerweb-scheduler:1.5.1\nimagePullPolicy: Always\nenv:\n- name: KUBERNETES_MODE\nvalue: \"yes\"\n- name: \"DATABASE_URI\"\nvalue: \"mariadb+pymysql://bunkerweb:changeme@svc-bunkerweb-db:3306/db\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-redis\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-redis\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-redis\nspec:\ncontainers:\n- name: bunkerweb-redis\nimage: redis:7-alpine\nimagePullPolicy: Always\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-db\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-db\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-db\nspec:\ncontainers:\n- name: bunkerweb-db\nimage: mariadb:10.10\nimagePullPolicy: Always\nenv:\n- name: MYSQL_RANDOM_ROOT_PASSWORD\nvalue: \"yes\"\n- name: \"MYSQL_DATABASE\"\nvalue: \"db\"\n- name: \"MYSQL_USER\"\nvalue: \"bunkerweb\"\n- name: \"MYSQL_PASSWORD\"\nvalue: \"changeme\"\nvolumeMounts:\n- mountPath: \"/var/lib/mysql\"\nname: vol-db\nvolumes:\n- name: vol-db\npersistentVolumeClaim:\nclaimName: pvc-bunkerweb\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: bunkerweb-ui\nspec:\nreplicas: 1\nstrategy:\ntype: Recreate\nselector:\nmatchLabels:\napp: bunkerweb-ui\ntemplate:\nmetadata:\nlabels:\napp: bunkerweb-ui\nspec:\ncontainers:\n- name: bunkerweb-ui\nimage: bunkerity/bunkerweb-ui:1.5.1\nimagePullPolicy: Always\nenv:\n- name: ADMIN_USERNAME\nvalue: \"changeme\"\n- name: \"ADMIN_PASSWORD\"\nvalue: \"changeme\"\n- name: KUBERNETES_MODE\nvalue: \"YES\"\n- name: \"DATABASE_URI\"\nvalue: \"mariadb+pymysql://bunkerweb:testor@svc-bunkerweb-db:3306/db\"\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-bunkerweb\nspec:\nclusterIP: None\nselector:\napp: bunkerweb\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-bunkerweb-db\nspec:\ntype: ClusterIP\nselector:\napp: bunkerweb-db\nports:\n- name: sql\nprotocol: TCP\nport: 3306\ntargetPort: 3306\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-bunkerweb-redis\nspec:\ntype: ClusterIP\nselector:\napp: bunkerweb-redis\nports:\n- name: redis\nprotocol: TCP\nport: 6379\ntargetPort: 6379\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: svc-bunkerweb-ui\nspec:\ntype: ClusterIP\nselector:\napp: bunkerweb-ui\nports:\n- name: http\nprotocol: TCP\nport: 7000\ntargetPort: 7000\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\nname: pvc-bunkerweb\nspec:\naccessModes:\n- ReadWriteOnce\nresources:\nrequests:\nstorage: 5Gi\nvolumeName: pv-bunkerweb\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\nname: ingress\nannotations:\nbunkerweb.io/www.example.com_USE_UI: \"yes\"\nbunkerweb.io/www.example.com_REVERSE_PROXY_INTERCEPT_ERRORS: \"no\"\nbunkerweb.io/www.example.com_INTERCEPTED_ERROR_CODES: '400 404 405 413 429 500 501 502 503 504'\nspec:\nrules:\n- host: www.example.com\nhttp:\npaths:\n- path: /changeme\npathType: Prefix\nbackend:\nservice:\nname: svc-bunkerweb-ui\nport:\nnumber: 7000\n</code></pre> <p>The installation of the web UI using the Linux integration is pretty straightforward because it is installed with BunkerWeb.</p> <p>The web UI comes as systemd service named <code>bunkerweb-ui</code> which is not enabled by default. If you want to start the web UI when on startup you can run the following command :</p> <pre><code>systemctl enable bunkerweb\n</code></pre> <p>A dedicated environment file located at <code>/etc/bunkerweb/ui.env</code> is used to configure the web UI :</p> <pre><code>ADMIN_USERNAME=changeme\nADMIN_PASSWORD=changeme\n</code></pre> <p>Each time you edit the <code>/etc/bunkerweb/ui.env</code> file, you will need to restart the service :</p> <pre><code>systemctl restart bunkerweb-ui\n</code></pre> <p>Accessing the web UI through BunkerWeb is a classical reverse proxy setup. Please note that the web UI is listening on the <code>7000</code> port and only on the loopback interface.</p> <p>Here is the <code>/etc/bunkerweb/variables.env</code> boilerplate you can use :</p> <pre><code>API_LISTEN_IP=127.0.0.1\nHTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nSERVER_NAME=www.example.com\nMULTISITE=yes\nwww.example.com_USE_UI=yes\nwww.example.com_USE_REVERSE_PROXY=yes\nwww.example.com_REVERSE_PROXY_URL=/changeme\nwww.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:7000\nwww.example.com_INTERCEPTED_ERROR_CODES=400 404 405 413 429 500 501 502 503 504\n</code></pre> <p>Don't forget to restart the <code>bunkerweb</code> service :</p> <pre><code>systemctl restart bunkerweb\n</code></pre> <p>The installation of the web UI using the Vagrant integration is pretty straightforward because it is installed with BunkerWeb.</p> <p>Create a <code>my_ui.env</code> filed used to configure the web UI :</p> <pre><code>ADMIN_USERNAME=changeme\nADMIN_PASSWORD=changeme\n</code></pre> <p>Here is the <code>my_variables.env</code> boilerplate you can use :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nSERVER_NAME=www.example.com\nMULTISITE=yes\nwww.example.com_USE_UI=yes\nwww.example.com_USE_REVERSE_PROXY=yes\nwww.example.com_REVERSE_PROXY_URL=/changeme\nwww.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:7000\nwww.example.com_INTERCEPTED_ERROR_CODES=400 404 405 413 429 500 501 502 503 504\n</code></pre> <p>The variable <code>enable_ui</code> can be set to <code>true</code> in order to activate the web UI service and the variable <code>custom_ui</code> can be used to specify the configuration file for the web UI :</p> <pre><code>[mybunkers]\n192.168.0.42 variables_env=\"{{ playbook_dir }}/my_variables.env\" enable_ui=true custom_ui=\"{{ playbook_dir }}/my_ui.env\"\n</code></pre> <p>Or alternatively, in your playbook file :</p> <pre><code>- hosts: all\nbecome: true\nvars:\n- variables_env: \"{{ playbook_dir }}/my_variables.env\"\n- enable_ui: true\n- custom_ui: \"{{ playbook_dir }}/my_ui.env\"\nroles:\n- bunkerity.bunkerweb\n</code></pre> <p>You can now run the playbook and be able to access the web UI :</p> <pre><code>ansible-playbook -i inventory.yml playbook.yml\n</code></pre> <p>The installation of the web UI using the Vagrant integration is pretty straightforward because it is installed with BunkerWeb.</p> <p>First of all, you will need to get a shell on your Vagrant box :</p> <pre><code>vagrant ssh\n</code></pre> <p>The web UI comes as systemd service named <code>bunkerweb-ui</code> which is not enabled by default. If you want to start the web UI when on startup you can run the following command :</p> <pre><code>systemctl enable bunkerweb\n</code></pre> <p>A dedicated environment file located at <code>/etc/bunkerweb/ui.env</code> is used to configure the web UI :</p> <pre><code>ADMIN_USERNAME=changeme\nADMIN_PASSWORD=changeme\n</code></pre> <p>Each time you edit the <code>/etc/bunkerweb/ui.env</code> file, you will need to restart the service :</p> <pre><code>systemctl restart bunkerweb-ui\n</code></pre> <p>Accessing the web UI through BunkerWeb is a classical reverse proxy setup. Please note that the web UI is listening on the <code>7000</code> port and only on the loopback interface.</p> <p>Here is the <code>/etc/bunkerweb/variables.env</code> boilerplate you can use :</p> <pre><code>HTTP_PORT=80\nHTTPS_PORT=443\nDNS_RESOLVERS=8.8.8.8 8.8.4.4\nSERVER_NAME=www.example.com\nMULTISITE=yes\nwww.example.com_USE_UI=yes\nwww.example.com_USE_REVERSE_PROXY=yes\nwww.example.com_REVERSE_PROXY_URL=/changeme\nwww.example.com_REVERSE_PROXY_HOST=http://127.0.0.1:7000\nwww.example.com_INTERCEPTED_ERROR_CODES=400 404 405 413 429 500 501 502 503 504\n</code></pre> <p>Don't forget to restart the <code>bunkerweb</code> service :</p> <pre><code>systemctl restart bunkerweb\n</code></pre>"}]}